<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <title>âœ¨ è·³è·³é³¥ Pro ğŸ¦</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      background: linear-gradient(135deg, #1a1a2e, #16213e);
      font-family: "Microsoft JhengHei", "Segoe UI", sans-serif;
      color: white;
      overflow: hidden;
    }
    canvas {
      border: 4px solid #4cc9f0;
      border-radius: 12px;
      box-shadow: 
        0 0 30px rgba(76, 201, 240, 0.6),
        0 0 60px rgba(106, 90, 205, 0.3);
      transition: transform 0.2s;
    }
    canvas:hover {
      transform: scale(1.01);
    }
    #ui {
      margin-top: 20px;
      text-align: center;
      background: rgba(0, 0, 0, 0.4);
      padding: 15px 25px;
      border-radius: 16px;
      width: 800px;
      backdrop-filter: blur(5px);
      border: 1px solid rgba(255,255,255,0.1);
    }
    button {
      margin: 6px;
      padding: 10px 20px;
      font-size: 17px;
      cursor: pointer;
      background: linear-gradient(to bottom, #4361ee, #3a0ca3);
      color: white;
      border: none;
      border-radius: 8px;
      font-weight: bold;
      transition: all 0.2s;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 12px rgba(0,0,0,0.4);
      background: linear-gradient(to bottom, #4870f0, #401cb0);
    }
    button:active {
      transform: translateY(1px);
    }
    #score, #highScore {
      font-size: 24px;
      margin: 10px 0;
      font-weight: bold;
      text-shadow: 0 0 8px rgba(255,255,255,0.5);
    }
    #multiplier {
      color: gold;
      font-size: 20px;
      height: 24px;
      margin-bottom: 8px;
      font-weight: bold;
      text-shadow: 0 0 10px rgba(255,215,0,0.7);
      animation: pulse 1.5s infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    .score-popup {
      position: absolute;
      color: #FFD700;
      font-weight: bold;
      font-size: 20px;
      pointer-events: none;
      opacity: 1;
      animation: floatUp 1s forwards;
    }
    @keyframes floatUp {
      0% { transform: translateY(0); opacity: 1; }
      100% { transform: translateY(-50px); opacity: 0; }
    }
  </style>
</head>
<body>
  <h1 style="font-size: 36px; margin-bottom: 10px; text-shadow: 0 0 15px #4cc9f0;">âœ¨ è·³è·³é³¥ Pro ğŸ¦</h1>
  <div id="gameContainer" style="position: relative;">
    <canvas id="gameCanvas" width="800" height="500"></canvas>
  </div>
  <div id="ui">
    <div id="multiplier"></div>
    <div id="score">åˆ†æ•¸ï¼š0</div>
    <div id="highScore">æœ€é«˜åˆ†ï¼š0</div>
    <div>
      <button id="easy">ç°¡å–®</button>
      <button id="medium">ä¸­ç´š</button>
      <button id="hard">å›°é›£</button>
      <button id="restart">é‡æ–°é–‹å§‹</button>
    </div>
    <p style="margin-top: 12px; font-size: 16px;">
      æ“ä½œï¼šæŒ‰ä¸‹ <strong>ç©ºç™½éµ</strong> æˆ– <strong>é»æ“Šç•«é¢</strong> è·³èºï½œæ”¶é›† ğŸ’« æ˜Ÿæ˜Ÿç²å¾— <strong>2 å€åˆ†æ•¸</strong>ï¼
    </p>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const highScoreEl = document.getElementById('highScore');
    const multiplierEl = document.getElementById('multiplier');
    const gameContainer = document.getElementById('gameContainer');

    // é›£åº¦è¨­å®š
    let difficulty = 'medium';
    const config = {
      easy:    { speed: 3, gap: 200, minHeight: 100, maxHeight: 200, starChance: 0.03 },
      medium:  { speed: 4, gap: 160, minHeight: 80,  maxHeight: 160, starChance: 0.02 },
      hard:    { speed: 5, gap: 120, minHeight: 60,  maxHeight: 120, starChance: 0.015 }
    };

    // éŠæˆ²ç‹€æ…‹
    let bird = { x: 150, y: 250, vy: 0, radius: 15, wingAngle: 0, angle: 0 };
    let pipes = [];
    let stars = [];
    let particles = [];
    let popups = [];
    let score = 0;
    let highScore = parseInt(localStorage.getItem('jumpBirdHighScore')) || 0;
    let gameRunning = false;
    let frameCount = 0;
    let multiplier = 1;
    let multiplierTimer = 0;
    let lastJumpTime = 0;
    const jumpCooldown = 150; // æ¯«ç§’

    highScoreEl.textContent = `æœ€é«˜åˆ†ï¼š${highScore}`;

    // åˆå§‹åŒ–
    function init() {
      bird = { x: 150, y: 250, vy: 0, radius: 15, wingAngle: 0, angle: 0 };
      pipes = [];
      stars = [];
      particles = [];
      popups = [];
      score = 0;
      multiplier = 1;
      multiplierTimer = 0;
      multiplierEl.textContent = '';
      frameCount = 0;
      gameRunning = true;
      scoreEl.textContent = `åˆ†æ•¸ï¼š${score}`;
    }

    // ç”Ÿæˆéšœç¤™
    function spawnPipe() {
      const gap = config[difficulty].gap;
      const minHeight = config[difficulty].minHeight;
      const maxHeight = config[difficulty].maxHeight;
      const topHeight = minHeight + Math.random() * (maxHeight - minHeight);
      pipes.push({
        x: canvas.width,
        topHeight,
        bottomY: topHeight + gap,
        width: 70,
        passed: false
      });

      if (Math.random() < config[difficulty].starChance) {
        stars.push({
          x: canvas.width + 35,
          y: topHeight + gap / 2,
          radius: 12,
          collected: false,
          rotation: 0
        });
      }
    }

    // èƒŒæ™¯æ¼¸è®Šï¼ˆæ ¹æ“šåˆ†æ•¸æ”¹è®Šæ™‚é–“ï¼‰
    function getSkyGradient() {
      const progress = Math.min(score / 30, 1); // 30 åˆ†å¾Œå®Œå…¨æ—¥è½
      const r1 = Math.floor(135 + 120 * progress);
      const g1 = Math.floor(206 - 100 * progress);
      const b1 = Math.floor(235 - 150 * progress);
      const r2 = Math.floor(224 - 100 * progress);
      const g2 = Math.floor(247 - 150 * progress);
      const b2 = Math.floor(250 - 180 * progress);
      const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      skyGradient.addColorStop(0, `rgb(${r1}, ${g1}, ${b1})`);
      skyGradient.addColorStop(1, `rgb(${r2}, ${g2}, ${b2})`);
      return skyGradient;
    }

    // é›²æœµ
    function drawCloud(x, y, size) {
      ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
      ctx.beginPath();
      ctx.arc(x, y, size * 0.5, 0, Math.PI * 2);
      ctx.arc(x + size * 0.4, y - size * 0.2, size * 0.45, 0, Math.PI * 2);
      ctx.arc(x + size * 0.8, y, size * 0.5, 0, Math.PI * 2);
      ctx.fill();
    }

    // ç¹ªè£½æ°´ç®¡ï¼ˆç¶“å…¸ Flappy é¢¨æ ¼ï¼‰
    function drawPipe(pipe) {
      const pipeTop = pipe.topHeight;
      const pipeBottom = pipe.bottomY;

      // ä¸Šç®¡
      ctx.fillStyle = '#7CFC00';
      ctx.fillRect(pipe.x, 0, pipe.width, pipeTop);
      // ä¸Šç®¡å¸½
      ctx.fillStyle = '#32CD32';
      ctx.fillRect(pipe.x - 5, pipeTop - 20, pipe.width + 10, 20);

      // ä¸‹ç®¡
      ctx.fillStyle = '#7CFC00';
      ctx.fillRect(pipe.x, pipeBottom, pipe.width, canvas.height - pipeBottom);
      // ä¸‹ç®¡å¸½
      ctx.fillStyle = '#32CD32';
      ctx.fillRect(pipe.x - 5, pipeBottom, pipe.width + 10, 20);
    }

    // ç¹ªè£½æ˜Ÿæ˜Ÿï¼ˆæ—‹è½‰ + ç™¼å…‰ï¼‰
    function drawStar(star) {
      if (star.collected) return;
      star.rotation += 0.05;
      ctx.save();
      ctx.translate(star.x, star.y);
      ctx.rotate(star.rotation);
      ctx.shadowColor = '#FFD700';
      ctx.shadowBlur = 15;
      ctx.fillStyle = '#FFD700';
      ctx.beginPath();
      for (let i = 0; i < 5; i++) {
        ctx.lineTo(
          Math.cos((i * 4 - 1) * Math.PI / 5) * star.radius,
          -Math.sin((i * 4 - 1) * Math.PI / 5) * star.radius
        );
        ctx.lineTo(
          Math.cos((i * 4) * Math.PI / 5) * star.radius / 2,
          -Math.sin((i * 4) * Math.PI / 5) * star.radius / 2
        );
      }
      ctx.closePath();
      ctx.fill();
      ctx.restore();
      ctx.shadowBlur = 0;
    }

    // ç¹ªè£½é³¥ï¼ˆè¶…å¯æ„›ç‰ˆï¼‰
    function drawBird() {
      // èº«é«”è§’åº¦
      bird.angle = Math.min(bird.vy * 0.1, 0.8);
      ctx.save();
      ctx.translate(bird.x, bird.y);
      ctx.rotate(bird.angle);

      // èº«é«”
      ctx.fillStyle = '#FFD700';
      ctx.beginPath();
      ctx.ellipse(0, 0, bird.radius, bird.radius - 2, 0, 0, Math.PI * 2);
      ctx.fill();

      // çœ¼ç›ç™½
      ctx.fillStyle = 'white';
      ctx.beginPath();
      ctx.arc(5, -4, 5, 0, Math.PI * 2);
      ctx.fill();

      // ç³å­”
      ctx.fillStyle = 'black';
      ctx.beginPath();
      ctx.arc(6, -4, 2.5, 0, Math.PI * 2);
      ctx.fill();

      // é«˜å…‰
      ctx.fillStyle = 'white';
      ctx.beginPath();
      ctx.arc(6.5, -4.5, 0.8, 0, Math.PI * 2);
      ctx.fill();

      // å–™
      ctx.fillStyle = '#FF8C00';
      ctx.beginPath();
      ctx.moveTo(12, 0);
      ctx.lineTo(22, -4);
      ctx.lineTo(22, 4);
      ctx.closePath();
      ctx.fill();

      // ç¿…è†€ï¼ˆå‹•æ…‹ï¼‰
      const wingOffset = Math.sin(bird.wingAngle) * 4;
      ctx.fillStyle = '#FFA500';
      ctx.beginPath();
      ctx.ellipse(-8, wingOffset, 10, 5, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    }

    // åˆ†æ•¸å½ˆè·³å‹•ç•«
    function createScorePopup(x, y, text) {
      popups.push({ x, y, text, life: 60 });
    }

    function updatePopups() {
      for (let i = popups.length - 1; i >= 0; i--) {
        const p = popups[i];
        p.life--;
        if (p.life <= 0) {
          popups.splice(i, 1);
        }
      }
    }

    function drawPopups() {
      popups.forEach(p => {
        const alpha = p.life / 60;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = '#FFD700';
        ctx.font = 'bold 20px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(p.text, p.x, p.y - (60 - p.life) * 0.8);
      });
      ctx.globalAlpha = 1;
    }

    // ç²’å­çˆ†ç‚¸
    function createExplosion(x, y) {
      for (let i = 0; i < 150; i++) {
        particles.push({
          x: x,
          y: y,
          vx: (Math.random() - 0.5) * 12,
          vy: (Math.random() - 0.5) * 12,
          life: 40 + Math.random() * 20,
          color: `hsl(${30 + Math.random() * 30}, 100%, ${50 + Math.random() * 30}%)`
        });
      }
      // éœ‡å‹•æ•ˆæœ
      canvas.style.transform = 'translateX(5px)';
      setTimeout(() => canvas.style.transform = 'translateX(-5px)', 50);
      setTimeout(() => canvas.style.transform = 'translateX(3px)', 100);
      setTimeout(() => canvas.style.transform = 'translateX(-3px)', 150);
      setTimeout(() => canvas.style.transform = '', 200);
    }

    function updateParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.15;
        p.life--;
        if (p.life <= 0) {
          particles.splice(i, 1);
        }
      }
    }

    function drawParticles() {
      particles.forEach(p => {
        ctx.globalAlpha = p.life / 60;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 2.5, 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.globalAlpha = 1;
    }

    // ç¢°æ’æª¢æ¸¬
    function checkCollision() {
      if (bird.y - bird.radius < 0 || bird.y + bird.radius > canvas.height) return true;

      for (let pipe of pipes) {
        if (bird.x + bird.radius > pipe.x && bird.x - bird.radius < pipe.x + pipe.width) {
          if (bird.y - bird.radius < pipe.topHeight || bird.y + bird.radius > pipe.bottomY) {
            return true;
          }
        }
      }

      for (let star of stars) {
        if (!star.collected) {
          const dx = bird.x - star.x;
          const dy = bird.y - star.y;
          if (Math.sqrt(dx*dx + dy*dy) < bird.radius + star.radius) {
            star.collected = true;
            multiplier = 2;
            multiplierTimer = 300;
            multiplierEl.textContent = 'åˆ†æ•¸ x2ï¼';
            createScorePopup(star.x, star.y, 'x2!');
            playSound(1);
          }
        }
      }
      return false;
    }

    // éŸ³æ•ˆæ¨¡æ“¬
    function playSound(type) {
      try {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.type = type === 1 ? 'square' : 'sine';
        osc.frequency.value = type === 1 ? 880 : 180;
        gain.gain.value = type === 1 ? 0.08 : 0.15;
        osc.start();
        setTimeout(() => osc.stop(), type === 1 ? 150 : 400);
      } catch (e) {}
    }

    // ä¸»è¿´åœˆ
    function update() {
      if (!gameRunning) return;

      // å€ç‡è¨ˆæ™‚
      if (multiplierTimer > 0) {
        multiplierTimer--;
        if (multiplierTimer <= 0) {
          multiplier = 1;
          multiplierEl.textContent = '';
        }
      }

      // é³¥ç‰©ç†
      bird.vy += 0.55;
      bird.y += bird.vy;
      bird.wingAngle += 0.3;

      // ç”Ÿæˆéšœç¤™
      frameCount++;
      if (frameCount % 90 === 0) {
        spawnPipe();
      }

      // æ›´æ–°éšœç¤™
      const speed = config[difficulty].speed;
      for (let i = pipes.length - 1; i >= 0; i--) {
        pipes[i].x -= speed;
        if (!pipes[i].passed && bird.x > pipes[i].x + pipes[i].width) {
          pipes[i].passed = true;
          const addScore = multiplier;
          score += addScore;
          scoreEl.textContent = `åˆ†æ•¸ï¼š${score}`;
          createScorePopup(bird.x, bird.y - 30, `+${addScore}`);
          playSound(1);
        }
        if (pipes[i].x + pipes[i].width < 0) {
          pipes.splice(i, 1);
        }
      }

      // æ›´æ–°æ˜Ÿæ˜Ÿ
      for (let i = stars.length - 1; i >= 0; i--) {
        stars[i].x -= speed;
        if (stars[i].x + stars[i].radius < 0 || stars[i].collected) {
          stars.splice(i, 1);
        }
      }

      // ç¢°æ’
      if (checkCollision()) {
        gameRunning = false;
        createExplosion(bird.x, bird.y);
        playSound(0);

        if (score > highScore) {
          highScore = score;
          localStorage.setItem('jumpBirdHighScore', highScore);
          highScoreEl.textContent = `æœ€é«˜åˆ†ï¼š${highScore}`;
        }

        let comment = '';
        if (score === 0) comment = 'å†è©¦ä¸€æ¬¡å§ï½é³¥å…’é‚„åœ¨å­¸ç¿’é£›ç¿”ï¼';
        else if (score < 5) comment = 'ä¸éŒ¯å–”ï½é³¥å…’å·²ç¶“èƒ½çŸ­æš«é£›è¡Œäº†ï¼';
        else if (score < 10) comment = 'å²å®³ï¼é³¥å…’å¿«è¦æˆç‚ºé£›è¡Œé«˜æ‰‹äº†ï¼';
        else if (score < 20) comment = 'é£›è¡Œé”äººï¼ç©¿éé¢¨æš´çš„å‹‡è€…ï¼';
        else comment = 'å‚³èªªç´šé£›è¡Œå¤§å¸«ï¼é€™éš»é³¥ç°¡ç›´åƒé¢¨ä¸€æ¨£è‡ªç”±ï¼';

        alert(`éŠæˆ²çµæŸï¼\nåˆ†æ•¸ï¼š${score}\n${comment}`);
        return;
      }

      // ç¹ªè£½
      ctx.fillStyle = getSkyGradient();
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // é›²æœµï¼ˆä¸‰å±¤ï¼‰
      drawCloud(100 + (frameCount * 0.3) % 900, 80, 40);
      drawCloud(400 + (frameCount * 0.2) % 1000, 60, 50);
      drawCloud(700 + (frameCount * 0.25) % 800, 100, 45);

      // éšœç¤™
      pipes.forEach(drawPipe);
      stars.forEach(drawStar);

      // é³¥
      drawBird();

      // æ•ˆæœ
      updateParticles();
      drawParticles();
      updatePopups();
      drawPopups();

      requestAnimationFrame(update);
    }

    // è·³èºï¼ˆé˜²é€£é»ï¼‰
    function jump() {
      const now = Date.now();
      if (!gameRunning || now - lastJumpTime < jumpCooldown) return;
      lastJumpTime = now;
      bird.vy = -8;
      playSound(1);
    }

    // æ§åˆ¶
    document.addEventListener('keydown', e => {
      if (e.code === 'Space') {
        if (!gameRunning) {
          init();
          update();
        } else {
          jump();
        }
        e.preventDefault();
      } else if (e.key === 'r' || e.key === 'R') {
        if (!gameRunning) {
          init();
          update();
        }
      }
    });

    canvas.addEventListener('click', () => {
      if (gameRunning) jump();
      else {
        init();
        update();
      }
    });

    // é›£åº¦æŒ‰éˆ•
    document.getElementById('easy').onclick = () => difficulty = 'easy';
    document.getElementById('medium').onclick = () => difficulty = 'medium';
    document.getElementById('hard').onclick = () => difficulty = 'hard';
    document.getElementById('restart').onclick = () => {
      init();
      update();
    };

    // é–‹å ´å‹•ç•«
    function drawStartScreen() {
      ctx.fillStyle = getSkyGradient();
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      drawCloud(200, 80, 40);
      drawCloud(500, 60, 50);
      drawCloud(700, 100, 45);
      
      // åœ°é¢
      ctx.fillStyle = '#228B22';
      ctx.fillRect(0, canvas.height - 20, canvas.width, 20);
      
      // é³¥ï¼ˆé£›å…¥å‹•ç•«ï¼‰
      const flyInX = Math.min(150, frameCount * 2);
      ctx.save();
      ctx.translate(flyInX, 250);
      ctx.fillStyle = '#FFD700';
      ctx.beginPath();
      ctx.arc(0, 0, 15, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = 'black';
      ctx.beginPath();
      ctx.arc(6, -3, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      ctx.fillStyle = 'white';
      ctx.font = 'bold 44px "Microsoft JhengHei"';
      ctx.textAlign = 'center';
      ctx.fillText('âœ¨ è·³è·³é³¥ Pro', canvas.width/2, canvas.height/2 - 50);
      ctx.font = '20px "Microsoft JhengHei"';
      ctx.fillText('æŒ‰ç©ºç™½éµæˆ–é»æ“Šç•«é¢é–‹å§‹éŠæˆ²', canvas.width/2, canvas.height/2 + 20);
      ctx.fillText('æ”¶é›† ğŸ’« æ˜Ÿæ˜Ÿç²å¾— 2 å€åˆ†æ•¸ï¼', canvas.width/2, canvas.height/2 + 50);

      if (frameCount < 100) {
        frameCount++;
        requestAnimationFrame(drawStartScreen);
      }
    }

    drawStartScreen();
  </script>
</body>
</html>