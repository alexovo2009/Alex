<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>äº”å­æ£‹ - å°æˆ° AI</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f5f5dc; /* é»ƒè‰²èƒŒæ™¯ï¼ˆç±³ç™½é»ƒï¼‰ */
            font-family: "Microsoft JhengHei", sans-serif;
            margin: 0;
            padding: 20px;
        }
        h1 {
            color: #333;
            margin-bottom: 10px;
        }
        #game-container {
            margin: 20px 0;
        }
        canvas {
            background-color: #e8d9a7;
            border: 2px solid #8B4513;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .controls {
            margin: 15px 0;
            text-align: center;
        }
        button {
            padding: 8px 16px;
            margin: 0 5px;
            font-size: 16px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
        }
        button:hover {
            background-color: #45a049;
        }
        select {
            padding: 6px 12px;
            font-size: 16px;
            margin: 0 10px;
        }
        #status {
            font-size: 20px;
            font-weight: bold;
            height: 30px;
            margin: 10px 0;
            color: #333;
        }
    </style>
</head>
<body>
    <h1>âš«âšª äº”å­æ£‹å°æˆ° AI</h1>
    <div class="controls">
        é›£åº¦ï¼š
        <select id="difficulty">
            <option value="easy">ç°¡å–®</option>
            <option value="medium" selected>ä¸­ç´š</option>
            <option value="hard">å›°é›£</option>
        </select>
        <button id="restart">é‡æ–°é–‹å§‹</button>
    </div>
    <div id="status">è¼ªåˆ°ä½ ï¼ˆé»‘å­ï¼‰</div>
    <div id="game-container">
        <canvas id="board" width="600" height="600"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('board');
        const ctx = canvas.getContext('2d');
        const statusEl = document.getElementById('status');
        const difficultySelect = document.getElementById('difficulty');
        const restartBtn = document.getElementById('restart');

        const BOARD_SIZE = 15; // 15x15 æ£‹ç›¤
        const CELL_SIZE = 40;
        const OFFSET = 20;
        const RADIUS = 16;

        let board = [];
        let currentPlayer = 1; // 1: é»‘å­ï¼ˆç©å®¶ï¼‰ï¼Œ-1: ç™½å­ï¼ˆAIï¼‰
        let gameActive = true;
        let difficulty = 'medium'; // 'easy', 'medium', 'hard'

        // åˆå§‹åŒ–æ£‹ç›¤ï¼ˆ0 ç‚ºç©ºï¼Œ1 é»‘ï¼Œ-1 ç™½ï¼‰
        function initBoard() {
            board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0));
            currentPlayer = 1;
            gameActive = true;
            statusEl.textContent = 'è¼ªåˆ°ä½ ï¼ˆé»‘å­ï¼‰';
            drawBoard();
        }

        // ç•«æ£‹ç›¤
        function drawBoard() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;

            // ç•«æ ¼ç·š
            for (let i = 0; i < BOARD_SIZE; i++) {
                // æ©«ç·š
                ctx.beginPath();
                ctx.moveTo(OFFSET, OFFSET + i * CELL_SIZE);
                ctx.lineTo(OFFSET + (BOARD_SIZE - 1) * CELL_SIZE, OFFSET + i * CELL_SIZE);
                ctx.stroke();

                // ç›´ç·š
                ctx.beginPath();
                ctx.moveTo(OFFSET + i * CELL_SIZE, OFFSET);
                ctx.lineTo(OFFSET + i * CELL_SIZE, OFFSET + (BOARD_SIZE - 1) * CELL_SIZE);
                ctx.stroke();
            }

            // ç•«å®šä½é»ï¼ˆå¤©å…ƒèˆ‡å››æ˜Ÿï¼‰
            const points = [
                [7, 7], // å¤©å…ƒ
                [3, 3], [3, 11], [11, 3], [11, 11]
            ];
            ctx.fillStyle = '#333';
            points.forEach(([x, y]) => {
                ctx.beginPath();
                ctx.arc(OFFSET + x * CELL_SIZE, OFFSET + y * CELL_SIZE, 4, 0, Math.PI * 2);
                ctx.fill();
            });

            // ç•«å·²æœ‰æ£‹å­
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    if (board[row][col] === 1) {
                        drawStone(col, row, 'black');
                    } else if (board[row][col] === -1) {
                        drawStone(col, row, 'white');
                    }
                }
            }
        }

        // ç•«å–®é¡†æ£‹å­
        function drawStone(col, row, color) {
            const x = OFFSET + col * CELL_SIZE;
            const y = OFFSET + row * CELL_SIZE;
            ctx.beginPath();
            ctx.arc(x, y, RADIUS, 0, Math.PI * 2);
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.stroke();

            if (color === 'white') {
                ctx.fillStyle = '#ccc';
                ctx.beginPath();
                ctx.arc(x - 4, y - 4, RADIUS / 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // æª¢æŸ¥æ˜¯å¦äº”é€£ï¼ˆä»¥æŸé»ç‚ºä¸­å¿ƒå‘å¤–æ“´å±•ï¼‰
        function checkWin(row, col, player) {
            const directions = [
                [0, 1],   // æ©«
                [1, 0],   // ç›´
                [1, 1],   // å³ä¸‹æ–œ
                [1, -1]   // å·¦ä¸‹æ–œ
            ];

            for (const [dx, dy] of directions) {
                let count = 1; // åŒ…å«ç•¶å‰é»

                // æ­£å‘ï¼ˆ+dx, +dyï¼‰
                for (let i = 1; i < 5; i++) {
                    const r = row + i * dx;
                    const c = col + i * dy;
                    if (r < 0 || r >= BOARD_SIZE || c < 0 || c >= BOARD_SIZE || board[r][c] !== player) break;
                    count++;
                }

                // åå‘ï¼ˆ-dx, -dyï¼‰
                for (let i = 1; i < 5; i++) {
                    const r = row - i * dx;
                    const c = col - i * dy;
                    if (r < 0 || r >= BOARD_SIZE || c < 0 || c >= BOARD_SIZE || board[r][c] !== player) break;
                    count++;
                }

                if (count >= 5) return true;
            }
            return false;
        }

        // æª¢æŸ¥æ˜¯å¦å¹³å±€ï¼ˆæ£‹ç›¤æ»¿ï¼‰
        function isBoardFull() {
            return board.every(row => row.every(cell => cell !== 0));
        }

        // ç©å®¶è½å­
        function makeMove(col, row) {
            if (!gameActive || board[row][col] !== 0) return false;

            board[row][col] = currentPlayer;
            drawStone(col, row, currentPlayer === 1 ? 'black' : 'white');

            if (checkWin(row, col, currentPlayer)) {
                const winner = currentPlayer === 1 ? 'ä½ ï¼ˆé»‘å­ï¼‰' : 'AIï¼ˆç™½å­ï¼‰';
                statusEl.textContent = `ğŸ‰ ${winner} å‹åˆ©ï¼`;
                gameActive = false;
                return true;
            }

            if (isBoardFull()) {
                statusEl.textContent = 'â›” å¹³å±€ï¼';
                gameActive = false;
                return true;
            }

            currentPlayer *= -1; // æ›é‚Š
            if (currentPlayer === -1 && gameActive) {
                statusEl.textContent = 'AI æ€è€ƒä¸­...';
                setTimeout(aiMove, difficulty === 'easy' ? 800 : difficulty === 'medium' ? 400 : 200);
            } else {
                statusEl.textContent = 'è¼ªåˆ°ä½ ï¼ˆé»‘å­ï¼‰';
            }
            return true;
        }

        // ===== AI é‚è¼¯ =====
        function aiMove() {
            if (!gameActive) return;

            let move;
            switch (difficulty) {
                case 'easy':
                    move = aiRandom();
                    break;
                case 'medium':
                    move = aiGreedy();
                    break;
                case 'hard':
                    move = aiMinimax(2); // æ·±åº¦2ï¼ˆé¿å…å¤ªæ…¢ï¼‰
                    break;
            }

            if (move) {
                const [row, col] = move;
                makeMove(col, row);
            } else {
                // è¬ä¸€æ‰¾ä¸åˆ°ï¼ˆç†è«–ä¸Šä¸æœƒï¼‰ï¼Œéš¨æ©Ÿè£œæ•‘
                move = aiRandom();
                if (move) makeMove(move[1], move[0]);
            }
        }

        // ç°¡å–®ï¼šéš¨æ©Ÿåˆæ³•ä½ç½®
        function aiRandom() {
            const empty = [];
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (board[r][c] === 0) empty.push([r, c]);
                }
            }
            return empty.length ? empty[Math.floor(Math.random() * empty.length)] : null;
        }

        // ä¸­ç´šï¼šè²ªå¿ƒç­–ç•¥ â€” æ‰¾èƒ½ã€Œè‡ªé€£å››ã€æˆ–ã€Œæ“‹å››ã€ã€ã€Œè‡ªé€£ä¸‰ã€ã€ã€Œæ“‹ä¸‰ã€çš„ä½ç½®
        function aiGreedy() {
            const threats = [
                { player: -1, need: 4, score: 10000 }, // è‡ªå·±å››é€£
                { player: 1,  need: 4, score: 9000  }, // æ“‹å°æ‰‹å››é€£
                { player: -1, need: 3, score: 1000  }, // è‡ªå·±æ´»ä¸‰
                { player: 1,  need: 3, score: 900   }, // æ“‹å°æ‰‹æ´»ä¸‰
                { player: -1, need: 2, score: 100   },
                { player: 1,  need: 2, score: 90    }
            ];

            let bestScore = -1;
            let bestMove = null;

            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (board[r][c] !== 0) continue;

                    let score = 0;
                    for (const { player, need, score: pt } of threats) {
                        if (countPattern(r, c, player, need)) {
                            score += pt;
                        }
                    }

                    // ä¸­å¿ƒåŠ æ¬Š
                    const centerDist = Math.abs(r - 7) + Math.abs(c - 7);
                    score += (8 - Math.min(7, centerDist)) * 2;

                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = [r, c];
                    }
                }
            }

            return bestMove;
        }

        // æª¢æŸ¥è‹¥åœ¨æ­¤è™•è½å­ï¼ˆplayer æ–¹å‘ï¼‰ï¼Œæ˜¯å¦æ§‹æˆã€Œè‡³å°‘ need å€‹é€£çºŒã€ï¼ˆå…©ç«¯é–‹ï¼‰
        function countPattern(row, col, player, need) {
            const dirs = [[0,1],[1,0],[1,1],[1,-1]];
            for (const [dx, dy] of dirs) {
                let count = 1; // å‡è¨­åœ¨æ­¤è™•è½å­
                let openEnds = 0;

                // æ­£å‘
                for (let i = 1; i <= need; i++) {
                    const r = row + i * dx;
                    const c = col + i * dy;
                    if (r < 0 || r >= BOARD_SIZE || c < 0 || c >= BOARD_SIZE) break;
                    if (board[r][c] === player) count++;
                    else if (board[r][c] === 0) { openEnds++; break; }
                    else break;
                }

                // åå‘
                for (let i = 1; i <= need; i++) {
                    const r = row - i * dx;
                    const c = col - i * dy;
                    if (r < 0 || r >= BOARD_SIZE || c < 0 || c >= BOARD_SIZE) break;
                    if (board[r][c] === player) count++;
                    else if (board[r][c] === 0) { openEnds++; break; }
                    else break;
                }

                if (count >= need && openEnds >= 1) return true; // è‡³å°‘ä¸€ç«¯é–‹æ”¾
            }
            return false;
        }

        // å›°é›£ï¼šMinimax + Alpha-Beta å‰ªæï¼ˆç°¡åŒ–ç‰ˆï¼Œæ·±åº¦=2ï¼‰
        function aiMinimax(depth) {
            let bestScore = -Infinity;
            let bestMove = null;

            const empty = [];
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (board[r][c] === 0) {
                        // å„ªå…ˆè€ƒæ…®é è¿‘å·²æœ‰æ£‹å­çš„é»ï¼ˆåŠ é€Ÿï¼‰
                        let near = false;
                        for (let dr = -2; dr <= 2; dr++) {
                            for (let dc = -2; dc <= 2; dc++) {
                                const nr = r + dr, nc = c + dc;
                                if (nr >= 0 && nr < BOARD_SIZE && nc >=0 && nc < BOARD_SIZE && board[nr][nc] !== 0) {
                                    near = true;
                                    break;
                                }
                            }
                            if (near) break;
                        }
                        if (near || empty.length < 20) empty.push([r, c]);
                    }
                }
            }

            for (const [r, c] of empty) {
                board[r][c] = -1; // AI ä¸‹å­
                const score = minimax(depth - 1, -Infinity, Infinity, false);
                board[r][c] = 0;

                if (score > bestScore) {
                    bestScore = score;
                    bestMove = [r, c];
                }
            }

            return bestMove;
        }

        function minimax(depth, alpha, beta, maximizingPlayer) {
            const winner = evaluateBoard();
            if (depth === 0 || winner !== 0) {
                return winner;
            }

            const empty = [];
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (board[r][c] === 0) empty.push([r, c]);
                }
            }

            if (maximizingPlayer) { // AI æœ€å¤§åŒ–
                let maxEval = -Infinity;
                for (const [r, c] of empty) {
                    board[r][c] = -1;
                    const eval = minimax(depth - 1, alpha, beta, false);
                    board[r][c] = 0;
                    maxEval = Math.max(maxEval, eval);
                    alpha = Math.max(alpha, eval);
                    if (beta <= alpha) break;
                }
                return maxEval;
            } else { // ç©å®¶æœ€å°åŒ–
                let minEval = Infinity;
                for (const [r, c] of empty) {
                    board[r][c] = 1;
                    const eval = minimax(depth - 1, alpha, beta, true);
                    board[r][c] = 0;
                    minEval = Math.min(minEval, eval);
                    beta = Math.min(beta, eval);
                    if (beta <= alpha) break;
                }
                return minEval;
            }
        }

        // è©•ä¼°å‡½æ•¸ï¼ˆç°¡å–®ç‰ˆï¼‰
        function evaluateBoard() {
            // è‹¥æœ‰å‹è² ï¼Œç›´æ¥è¿”å›å¤§å¹…åˆ†æ•¸
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (board[r][c] !== 0 && checkWin(r, c, board[r][c])) {
                        return board[r][c] === -1 ? 100000 : -100000;
                    }
                }
            }

            // å¦å‰‡ä»¥æ¨¡å¼è¨ˆåˆ†
            let score = 0;
            const dirs = [[0,1],[1,0],[1,1],[1,-1]];
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (board[r][c] === 0) continue;
                    const player = board[r][c];
                    const multiplier = player === -1 ? 1 : -1;
                    for (const [dx, dy] of dirs) {
                        let count = 1;
                        // æ­£å‘
                        for (let i = 1; i < 5; i++) {
                            const nr = r + i * dx, nc = c + i * dy;
                            if (nr < 0 || nr >= BOARD_SIZE || nc < 0 || nc >= BOARD_SIZE) break;
                            if (board[nr][nc] === player) count++;
                            else if (board[nr][nc] !== 0) break;
                            else break;
                        }
                        // åå‘
                        for (let i = 1; i < 5; i++) {
                            const nr = r - i * dx, nc = c - i * dy;
                            if (nr < 0 || nr >= BOARD_SIZE || nc < 0 || nc >= BOARD_SIZE) break;
                            if (board[nr][nc] === player) count++;
                            else if (board[nr][nc] !== 0) break;
                            else break;
                        }
                        if (count >= 2) score += multiplier * Math.pow(10, count - 1);
                    }
                }
            }
            return score;
        }

        // æ»‘é¼ é»æ“Šäº‹ä»¶
        canvas.addEventListener('click', (e) => {
            if (!gameActive || currentPlayer !== 1) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const col = Math.round((x - OFFSET) / CELL_SIZE);
            const row = Math.round((y - OFFSET) / CELL_SIZE);

            if (col >= 0 && col < BOARD_SIZE && row >= 0 && row < BOARD_SIZE) {
                makeMove(col, row);
            }
        });

        // é›£åº¦é¸æ“‡è®Šæ›´
        difficultySelect.addEventListener('change', () => {
            difficulty = difficultySelect.value;
        });

        // é‡æ–°é–‹å§‹
        restartBtn.addEventListener('click', () => {
            difficulty = difficultySelect.value;
            initBoard();
        });

        // åˆå§‹åŒ–
        initBoard();
    </script>
</body>
</html>