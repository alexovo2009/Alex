<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>âš«âšª äº”å­æ£‹å°æˆ° AI</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: linear-gradient(135deg, #f9f3e9, #e8d9a7);
            font-family: "Microsoft JhengHei", "Segoe UI", sans-serif;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
        }
        h1 {
            color: #5a3921;
            margin-bottom: 10px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
            font-size: 28px;
        }
        #game-container {
            margin: 20px 0;
            position: relative;
        }
        canvas {
            background-color: #f0e0c0;
            border: 3px solid #8B4513;
            border-radius: 8px;
            box-shadow: 0 6px 12px rgba(0,0,0,0.25), inset 0 0 20px rgba(139,69,19,0.1);
        }
        .controls {
            margin: 15px 0;
            text-align: center;
            display: flex;
            gap: 12px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
        }
        button {
            padding: 10px 18px;
            font-size: 16px;
            cursor: pointer;
            background: linear-gradient(to bottom, #5a9c6e, #45a049);
            color: white;
            border: none;
            border-radius: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: all 0.2s;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        button:active {
            transform: translateY(1px);
        }
        button#undo {
            background: linear-gradient(to bottom, #d9a76e, #c98a4e);
        }
        select {
            padding: 8px 14px;
            font-size: 16px;
            border-radius: 20px;
            border: 1px solid #aaa;
            background: white;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }
        #status {
            font-size: 22px;
            font-weight: bold;
            height: 32px;
            margin: 12px 0;
            color: #5a3921;
            text-align: center;
            background: rgba(255,255,255,0.7);
            padding: 6px 20px;
            border-radius: 20px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
            transition: all 0.3s;
        }
        .thinking {
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
    </style>
</head>
<body>
    <h1>âš«âšª äº”å­æ£‹å°æˆ° AI</h1>
    <div class="controls">
        é›£åº¦ï¼š
        <select id="difficulty">
            <option value="easy">ç°¡å–®</option>
            <option value="medium" selected>ä¸­ç´š</option>
            <option value="hard">å›°é›£</option>
        </select>
        <button id="restart">ğŸ”„ é‡æ–°é–‹å§‹</button>
        <button id="undo">â†©ï¸ æ‚”æ£‹ï¼ˆé™1æ¬¡ï¼‰</button>
    </div>
    <div id="status">è¼ªåˆ°ä½ ï¼ˆé»‘å­ï¼‰</div>
    <div id="game-container">
        <canvas id="board" width="600" height="600"></canvas>
    </div>

    <script>
        // ===== éŸ³æ•ˆç”Ÿæˆï¼ˆç„¡éœ€å¤–éƒ¨æ–‡ä»¶ï¼‰=====
        function playSound(frequency, duration = 0.2, type = 'sine') {
            try {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = type;
                osc.frequency.value = frequency;
                gain.gain.setValueAtTime(0.1, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start();
                osc.stop(ctx.currentTime + duration);
            } catch (e) {
                // å¿½ç•¥ä¸æ”¯æŒçš„ç€è¦½å™¨
            }
        }

        // ===== åˆå§‹åŒ– =====
        const canvas = document.getElementById('board');
        const ctx = canvas.getContext('2d');
        const statusEl = document.getElementById('status');
        const difficultySelect = document.getElementById('difficulty');
        const restartBtn = document.getElementById('restart');
        const undoBtn = document.getElementById('undo');

        const BOARD_SIZE = 15;
        const CELL_SIZE = 40;
        const OFFSET = 20;
        const RADIUS = 16;

        let board = [];
        let currentPlayer = 1; // 1: é»‘ï¼ˆç©å®¶ï¼‰ï¼Œ-1: ç™½ï¼ˆAIï¼‰
        let gameActive = true;
        let difficulty = 'medium';
        let undoUsed = false;
        let moveHistory = []; // ç”¨æ–¼æ‚”æ£‹
        let hoverPos = null;

        // åˆå§‹åŒ–æ£‹ç›¤
        function initBoard() {
            board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0));
            currentPlayer = 1;
            gameActive = true;
            undoUsed = false;
            moveHistory = [];
            statusEl.textContent = 'è¼ªåˆ°ä½ ï¼ˆé»‘å­ï¼‰';
            statusEl.className = '';
            hoverPos = null;
            drawBoard();
            undoBtn.disabled = false;
        }

        // ç•«æ£‹ç›¤
        function drawBoard() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 1.2;

            // æ ¼ç·š
            for (let i = 0; i < BOARD_SIZE; i++) {
                ctx.beginPath();
                ctx.moveTo(OFFSET, OFFSET + i * CELL_SIZE);
                ctx.lineTo(OFFSET + (BOARD_SIZE - 1) * CELL_SIZE, OFFSET + i * CELL_SIZE);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(OFFSET + i * CELL_SIZE, OFFSET);
                ctx.lineTo(OFFSET + i * CELL_SIZE, OFFSET + (BOARD_SIZE - 1) * CELL_SIZE);
                ctx.stroke();
            }

            // å®šä½é»
            const points = [[7,7], [3,3], [3,11], [11,3], [11,11]];
            ctx.fillStyle = '#5a3921';
            points.forEach(([x, y]) => {
                ctx.beginPath();
                ctx.arc(OFFSET + x * CELL_SIZE, OFFSET + y * CELL_SIZE, 3.5, 0, Math.PI * 2);
                ctx.fill();
            });

            // æ£‹å­
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    if (board[row][col] === 1) drawStone(col, row, 'black');
                    else if (board[row][col] === -1) drawStone(col, row, 'white');
                }
            }

            // æ‡¸åœé è¦½
            if (hoverPos && currentPlayer === 1 && gameActive) {
                const [col, row] = hoverPos;
                if (board[row][col] === 0) {
                    ctx.globalAlpha = 0.5;
                    drawStone(col, row, 'black');
                    ctx.globalAlpha = 1.0;
                }
            }
        }

        function drawStone(col, row, color) {
            const x = OFFSET + col * CELL_SIZE;
            const y = OFFSET + row * CELL_SIZE;
            ctx.beginPath();
            ctx.arc(x, y, RADIUS, 0, Math.PI * 2);
            ctx.shadowColor = 'rgba(0,0,0,0.3)';
            ctx.shadowBlur = 5;
            ctx.fillStyle = color;
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1.5;
            ctx.stroke();

            // å…‰æ¾¤
            if (color === 'white') {
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(x - 5, y - 5, RADIUS / 3, 0, Math.PI * 2);
                ctx.fill();
            } else {
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.arc(x - 4, y - 4, RADIUS / 4, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // å‹åˆ©æª¢æŸ¥
        function checkWin(row, col, player) {
            const dirs = [[0,1],[1,0],[1,1],[1,-1]];
            for (const [dx, dy] of dirs) {
                let count = 1;
                for (let i = 1; i < 5; i++) {
                    const r = row + i * dx, c = col + i * dy;
                    if (r < 0 || r >= BOARD_SIZE || c < 0 || c >= BOARD_SIZE || board[r][c] !== player) break;
                    count++;
                }
                for (let i = 1; i < 5; i++) {
                    const r = row - i * dx, c = col - i * dy;
                    if (r < 0 || r >= BOARD_SIZE || c < 0 || c >= BOARD_SIZE || board[r][c] !== player) break;
                    count++;
                }
                if (count >= 5) return true;
            }
            return false;
        }

        function isBoardFull() {
            return board.every(row => row.every(cell => cell !== 0));
        }

        // è½å­
        function makeMove(col, row) {
            if (!gameActive || board[row][col] !== 0) return false;

            // è¨˜éŒ„æ­·å²ï¼ˆç”¨æ–¼æ‚”æ£‹ï¼‰
            moveHistory.push({row, col, player: currentPlayer});

            board[row][col] = currentPlayer;
            drawBoard();

            if (checkWin(row, col, currentPlayer)) {
                const winner = currentPlayer === 1 ? 'ä½ ï¼ˆé»‘å­ï¼‰' : 'AIï¼ˆç™½å­ï¼‰';
                statusEl.textContent = `ğŸ‰ ${winner} å‹åˆ©ï¼`;
                statusEl.style.color = '#d35400';
                gameActive = false;
                playSound(currentPlayer === 1 ? 523 : 349, 0.4); // C5 / F4
                if (currentPlayer === 1) celebrateWin();
                return true;
            }

            if (isBoardFull()) {
                statusEl.textContent = 'â›” å¹³å±€ï¼';
                statusEl.style.color = '#7f8c8d';
                gameActive = false;
                playSound(440, 0.3);
                return true;
            }

            currentPlayer *= -1;
            if (currentPlayer === -1 && gameActive) {
                statusEl.textContent = 'AI æ€è€ƒä¸­... ğŸ¤”';
                statusEl.className = 'thinking';
                setTimeout(aiMove, difficulty === 'easy' ? 800 : difficulty === 'medium' ? 400 : 200);
            } else {
                statusEl.textContent = 'è¼ªåˆ°ä½ ï¼ˆé»‘å­ï¼‰';
                statusEl.className = '';
            }
            return true;
        }

        // æ…¶ç¥å‹•ç•«
        function celebrateWin() {
            const particles = [];
            for (let i = 0; i < 100; i++) {
                particles.push({
                    x: canvas.width / 2,
                    y: canvas.height / 2,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8 - 4,
                    life: 60,
                    color: ['#ff9ff3', '#feca57', '#48dbfb', '#1dd1a1'][Math.floor(Math.random() * 4)]
                });
            }

            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawBoard(); // é‡ç¹ªæ£‹ç›¤èˆ‡æ£‹å­

                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.1;
                    p.life--;
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = p.life / 60;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1.0;

                if (particles.some(p => p.life > 0)) {
                    requestAnimationFrame(animate);
                } else {
                    drawBoard(); // æœ€å¾Œæ¢å¾©
                }
            }
            animate();
        }

        // ===== AI é‚è¼¯ï¼ˆä¿ç•™åŸé‚è¼¯ï¼Œåƒ…å¾®èª¿ï¼‰=====
        function aiRandom() {
            const empty = [];
            for (let r = 0; r < BOARD_SIZE; r++)
                for (let c = 0; c < BOARD_SIZE; c++)
                    if (board[r][c] === 0) empty.push([r, c]);
            return empty.length ? empty[Math.floor(Math.random() * empty.length)] : null;
        }

        function countPattern(row, col, player, need) {
            const dirs = [[0,1],[1,0],[1,1],[1,-1]];
            for (const [dx, dy] of dirs) {
                let count = 1, openEnds = 0;
                for (let i = 1; i <= need; i++) {
                    const r = row + i * dx, c = col + i * dy;
                    if (r < 0 || r >= BOARD_SIZE || c < 0 || c >= BOARD_SIZE) break;
                    if (board[r][c] === player) count++;
                    else if (board[r][c] === 0) { openEnds++; break; }
                    else break;
                }
                for (let i = 1; i <= need; i++) {
                    const r = row - i * dx, c = col - i * dy;
                    if (r < 0 || r >= BOARD_SIZE || c < 0 || c >= BOARD_SIZE) break;
                    if (board[r][c] === player) count++;
                    else if (board[r][c] === 0) { openEnds++; break; }
                    else break;
                }
                if (count >= need && openEnds >= 1) return true;
            }
            return false;
        }

        function aiGreedy() {
            const threats = [
                { player: -1, need: 4, score: 10000 },
                { player: 1,  need: 4, score: 9000  },
                { player: -1, need: 3, score: 1000  },
                { player: 1,  need: 3, score: 900   },
                { player: -1, need: 2, score: 100   },
                { player: 1,  need: 2, score: 90    }
            ];

            let bestScore = -1;
            let bestMove = null;

            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (board[r][c] !== 0) continue;
                    let score = 0;
                    for (const t of threats) {
                        if (countPattern(r, c, t.player, t.need)) score += t.score;
                    }
                    const centerDist = Math.abs(r - 7) + Math.abs(c - 7);
                    score += (8 - Math.min(7, centerDist)) * 2;
                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = [r, c];
                    }
                }
            }
            return bestMove;
        }

        function evaluateBoard() {
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (board[r][c] !== 0 && checkWin(r, c, board[r][c])) {
                        return board[r][c] === -1 ? 100000 : -100000;
                    }
                }
            }
            let score = 0;
            const dirs = [[0,1],[1,0],[1,1],[1,-1]];
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (board[r][c] === 0) continue;
                    const player = board[r][c];
                    const mult = player === -1 ? 1 : -1;
                    for (const [dx, dy] of dirs) {
                        let count = 1;
                        for (let i = 1; i < 5; i++) {
                            const nr = r + i * dx, nc = c + i * dy;
                            if (nr < 0 || nr >= BOARD_SIZE || nc < 0 || nc >= BOARD_SIZE) break;
                            if (board[nr][nc] === player) count++;
                            else if (board[nr][nc] !== 0) break;
                            else break;
                        }
                        for (let i = 1; i < 5; i++) {
                            const nr = r - i * dx, nc = c - i * dy;
                            if (nr < 0 || nr >= BOARD_SIZE || nc < 0 || nc >= BOARD_SIZE) break;
                            if (board[nr][nc] === player) count++;
                            else if (board[nr][nc] !== 0) break;
                            else break;
                        }
                        if (count >= 2) score += mult * Math.pow(10, count - 1);
                    }
                }
            }
            return score;
        }

        function aiMinimax(depth) {
            let bestScore = -Infinity;
            let bestMove = null;
            const empty = [];
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (board[r][c] === 0) {
                        let near = false;
                        for (let dr = -2; dr <= 2; dr++) {
                            for (let dc = -2; dc <= 2; dc++) {
                                const nr = r + dr, nc = c + dc;
                                if (nr >= 0 && nr < BOARD_SIZE && nc >=0 && nc < BOARD_SIZE && board[nr][nc] !== 0) {
                                    near = true; break;
                                }
                            }
                            if (near) break;
                        }
                        if (near || empty.length < 20) empty.push([r, c]);
                    }
                }
            }
            for (const [r, c] of empty) {
                board[r][c] = -1;
                const score = minimax(depth - 1, -Infinity, Infinity, false);
                board[r][c] = 0;
                if (score > bestScore) {
                    bestScore = score;
                    bestMove = [r, c];
                }
            }
            return bestMove;
        }

        function minimax(depth, alpha, beta, maximizing) {
            const winner = evaluateBoard();
            if (depth === 0 || Math.abs(winner) === 100000) return winner;

            const empty = [];
            for (let r = 0; r < BOARD_SIZE; r++)
                for (let c = 0; c < BOARD_SIZE; c++)
                    if (board[r][c] === 0) empty.push([r, c]);

            if (maximizing) {
                let maxEval = -Infinity;
                for (const [r, c] of empty) {
                    board[r][c] = -1;
                    const eval = minimax(depth - 1, alpha, beta, false);
                    board[r][c] = 0;
                    maxEval = Math.max(maxEval, eval);
                    alpha = Math.max(alpha, eval);
                    if (beta <= alpha) break;
                }
                return maxEval;
            } else {
                let minEval = Infinity;
                for (const [r, c] of empty) {
                    board[r][c] = 1;
                    const eval = minimax(depth - 1, alpha, beta, true);
                    board[r][c] = 0;
                    minEval = Math.min(minEval, eval);
                    beta = Math.min(beta, eval);
                    if (beta <= alpha) break;
                }
                return minEval;
            }
        }

        function aiMove() {
            if (!gameActive) return;
            let move;
            switch (difficulty) {
                case 'easy': move = aiRandom(); break;
                case 'medium': move = aiGreedy(); break;
                case 'hard': move = aiMinimax(2); break;
            }
            if (!move) move = aiRandom();
            if (move) {
                const [row, col] = move;
                makeMove(col, row);
            }
        }

        // ===== äº‹ä»¶è™•ç† =====
        canvas.addEventListener('mousemove', (e) => {
            if (!gameActive || currentPlayer !== 1) return;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const col = Math.round((x - OFFSET) / CELL_SIZE);
            const row = Math.round((y - OFFSET) / CELL_SIZE);
            if (col >= 0 && col < BOARD_SIZE && row >= 0 && row < BOARD_SIZE) {
                hoverPos = [col, row];
                drawBoard();
            }
        });

        canvas.addEventListener('click', (e) => {
            if (!gameActive || currentPlayer !== 1) return;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const col = Math.round((x - OFFSET) / CELL_SIZE);
            const row = Math.round((y - OFFSET) / CELL_SIZE);
            if (col >= 0 && col < BOARD_SIZE && row >= 0 && row < BOARD_SIZE) {
                makeMove(col, row);
            }
        });

        difficultySelect.addEventListener('change', () => {
            difficulty = difficultySelect.value;
        });

        restartBtn.addEventListener('click', initBoard);

        undoBtn.addEventListener('click', () => {
            if (undoUsed || !gameActive || moveHistory.length === 0 || currentPlayer !== 1) return;
            // æ’¤éŠ·ç©å®¶æœ€å¾Œä¸€æ­¥
            while (moveHistory.length > 0) {
                const last = moveHistory.pop();
                if (last.player === 1) {
                    board[last.row][last.col] = 0;
                    undoUsed = true;
                    undoBtn.disabled = true;
                    gameActive = true;
                    currentPlayer = 1;
                    statusEl.textContent = 'è¼ªåˆ°ä½ ï¼ˆé»‘å­ï¼‰';
                    statusEl.className = '';
                    drawBoard();
                    break;
                }
            }
        });

        initBoard();
    </script>
</body>
</html>