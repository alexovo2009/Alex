<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>âš«âšª äº”å­æ£‹å°æˆ° AI</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: linear-gradient(135deg, #f9f3e9, #e8d9a7);
            font-family: "Microsoft JhengHei", "Segoe UI", sans-serif;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
        }
        h1 {
            color: #5a3921;
            margin-bottom: 10px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
            font-size: 28px;
        }
        #game-container {
            margin: 20px 0;
            position: relative;
        }
        canvas {
            background-color: #f0e0c0;
            border: 3px solid #8B4513;
            border-radius: 8px;
            box-shadow: 0 6px 12px rgba(0,0,0,0.25), inset 0 0 20px rgba(139,69,19,0.1);
        }
        .controls {
            margin: 15px 0;
            text-align: center;
            display: flex;
            gap: 12px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
        }
        button {
            padding: 10px 18px;
            font-size: 16px;
            cursor: pointer;
            background: linear-gradient(to bottom, #5a9c6e, #45a049);
            color: white;
            border: none;
            border-radius: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: all 0.2s;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        button:active {
            transform: translateY(1px);
        }
        button#undo {
            background: linear-gradient(to bottom, #d9a76e, #c98a4e);
        }
        select {
            padding: 8px 14px;
            font-size: 16px;
            border-radius: 20px;
            border: 1px solid #aaa;
            background: white;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }
        #status {
            font-size: 22px;
            font-weight: bold;
            height: 32px;
            margin: 12px 0;
            color: #5a3921;
            text-align: center;
            background: rgba(255,255,255,0.7);
            padding: 6px 20px;
            border-radius: 20px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
            transition: all 0.3s;
        }
        .thinking {
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* é–‹å§‹ç•«é¢æ¨£å¼ */
        .start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #2c3e50, #4a6491);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
            font-family: "Microsoft JhengHei", "Segoe UI", sans-serif;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
            animation: fadeIn 0.8s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .start-content {
            max-width: 800px;
            padding: 40px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3),
                        inset 0 1px 0 rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .game-title {
            font-size: 5rem;
            font-weight: bold;
            margin: 0 0 10px 0;
            color: #fff;
            text-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            letter-spacing: 3px;
            background: linear-gradient(45deg, #f9f3e9, #e8d9a7);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            font-size: 1.8rem;
            margin-bottom: 40px;
            color: #d4e6ff;
            opacity: 0.9;
        }

        .instructions {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 20px;
            padding: 20px;
            margin: 30px 0;
            font-size: 1.2rem;
            line-height: 1.6;
            text-align: left;
            display: inline-block;
            border-left: 4px solid #5a9c6e;
        }

        .instructions p {
            margin: 10px 0;
        }

        .start-prompt {
            margin-top: 40px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 20px;
            animation: pulsePrompt 2s infinite;
        }

        @keyframes pulsePrompt {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.9; }
        }

        .start-prompt p {
            font-size: 1.8rem;
            font-weight: bold;
            margin: 0 0 10px 0;
            color: #ffd166;
        }

        .key-hint {
            font-size: 1rem;
            color: #a8d5e2;
            font-style: italic;
        }

        .game-main {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            animation: fadeInUp 0.8s ease;
        }

        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* æŒ‰éˆ•æ¨£å¼æ”¹é€² */
        button#hint {
            background: linear-gradient(to bottom, #6c5ce7, #5b4fcf);
        }

        button#show-stats {
            background: linear-gradient(to bottom, #6c7b8b, #5a6b7a);
            font-size: 14px;
            padding: 8px 16px;
            margin-top: 10px;
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2) !important;
        }

        /* çµ±è¨ˆé¢æ¿æ¨£å¼ */
        #stats-panel {
            margin-top: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(139, 69, 19, 0.2);
            transition: all 0.3s ease;
        }

        #stats-panel:hover {
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
            transform: translateY(-2px);
        }

        /* æ£‹å­å‹•ç•« */
        @keyframes stoneDrop {
            0% { transform: scale(0); opacity: 0; }
            70% { transform: scale(1.1); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }

        .stone-animation {
            animation: stoneDrop 0.3s ease-out;
        }

        /* éŸ¿æ‡‰å¼è¨­è¨ˆ */
        @media (max-width: 650px) {
            canvas {
                width: 95vw;
                height: 95vw;
                max-width: 500px;
                max-height: 500px;
            }
            
            .controls {
                flex-direction: column;
                gap: 10px;
            }
            
            #stats-panel {
                padding: 15px;
                margin: 15px 10px;
            }
            
            .game-title {
                font-size: 3.5rem;
            }
        }
    </style>
</head>
<body>
    <!-- é–‹å§‹ç•«é¢ -->
    <div id="start-screen" class="start-screen">
        <div class="start-content">
            <h1 class="game-title">äº”å­æ£‹</h1>
            <div class="subtitle">âš«âšª äº”å­æ£‹å°æˆ° AI</div>
            <div class="instructions">
                <p>ä½¿ç”¨æ»‘é¼ é»æ“Šæ£‹ç›¤è½å­</p>
                <p>ç›®æ¨™ï¼šåœ¨æ©«ã€è±æˆ–æ–œç·šä¸Šé€£æˆäº”å­</p>
            </div>
            <div class="start-prompt">
                <p>æŒ‰ä»»æ„éµé–‹å§‹éŠæˆ²</p>
                <div class="key-hint">æˆ–é»æ“Šæ­¤è™•</div>
            </div>
        </div>
    </div>

    <!-- éŠæˆ²ä¸»ç•«é¢ï¼ˆåˆå§‹éš±è—ï¼‰ -->
    <div id="game-main" class="game-main" style="display: none;">
        <h1>âš«âšª äº”å­æ£‹å°æˆ° AI</h1>
        <div class="controls">
            é›£åº¦ï¼š
            <select id="difficulty">
                <option value="easy">ç°¡å–®ï¼ˆéš¨æ©Ÿï¼‰</option>
                <option value="medium" selected>ä¸­ç´šï¼ˆè²ªå¿ƒï¼‰</option>
                <option value="hard">å›°é›£ï¼ˆMinimax 2å±¤ï¼‰</option>
                <option value="expert">å°ˆå®¶ï¼ˆMinimax 3å±¤ï¼‰</option>
                <option value="impossible">ä¸å¯èƒ½ï¼ˆMinimax 4å±¤ï¼‰</option>
            </select>
            <button id="restart">ğŸ”„ é‡æ–°é–‹å§‹</button>
            <button id="undo">â†©ï¸ æ‚”æ£‹ï¼ˆé™1æ¬¡ï¼‰</button>
            <button id="hint">ğŸ’¡ æç¤ºï¼ˆé™3æ¬¡ï¼‰</button>
        </div>
        <div id="status">è¼ªåˆ°ä½ ï¼ˆé»‘å­ï¼‰</div>
        <div id="game-container">
            <canvas id="board" width="600" height="600"></canvas>
        </div>
        <div id="stats-panel" style="margin-top: 20px; background: rgba(255,255,255,0.8); padding: 15px; border-radius: 15px; box-shadow: 0 3px 10px rgba(0,0,0,0.1); max-width: 600px; width: 100%;">
            <h3 style="margin-top: 0; color: #5a3921;">ğŸ“Š éŠæˆ²çµ±è¨ˆ</h3>
            <div style="display: flex; flex-wrap: wrap; gap: 20px; justify-content: space-between;">
                <div>
                    <div><strong>å‹å ´:</strong> <span id="stat-wins">0</span></div>
                    <div><strong>æ•—å ´:</strong> <span id="stat-losses">0</span></div>
                    <div><strong>å¹³å±€:</strong> <span id="stat-draws">0</span></div>
                    <div><strong>ç¸½éŠæˆ²:</strong> <span id="stat-total">0</span></div>
                </div>
                <div>
                    <div><strong>ç•¶å‰é€£å‹:</strong> <span id="stat-streak">0</span></div>
                    <div><strong>æœ€ä½³é€£å‹:</strong> <span id="stat-best-streak">0</span></div>
                    <div><strong>å‹ç‡:</strong> <span id="stat-win-rate">0%</span></div>
                </div>
                <div style="flex: 1; min-width: 200px;">
                    <div><strong>ğŸ¯ æˆå°±:</strong></div>
                    <div id="achievements-list" style="font-size: 14px; margin-top: 5px;">
                        <!-- æˆå°±å°‡å‹•æ…‹é¡¯ç¤º -->
                    </div>
                </div>
            </div>
            <button id="show-stats" style="margin-top: 10px; padding: 8px 16px; font-size: 14px; background: linear-gradient(to bottom, #6c7b8b, #5a6b7a);">ğŸ“ˆ è©³ç´°çµ±è¨ˆ</button>
        </div>
    </div>

    <script>
        // ===== éŸ³æ•ˆç”Ÿæˆï¼ˆç„¡éœ€å¤–éƒ¨æ–‡ä»¶ï¼‰=====
        function playSound(frequency, duration = 0.2, type = 'sine', volume = 0.1) {
            try {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = type;
                osc.frequency.value = frequency;
                gain.gain.setValueAtTime(volume, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start();
                osc.stop(ctx.currentTime + duration);
            } catch (e) {
                // å¿½ç•¥ä¸æ”¯æŒçš„ç€è¦½å™¨
            }
        }

        // ç‰¹æ®ŠéŸ³æ•ˆ
        function playStoneSound(player) {
            if (player === 1) {
                // é»‘å­éŸ³æ•ˆ - è¼ƒä½æ²‰
                playSound(220, 0.15, 'sine', 0.08);
                playSound(277, 0.1, 'sine', 0.05);
            } else {
                // ç™½å­éŸ³æ•ˆ - è¼ƒæ¸…è„†
                playSound(440, 0.15, 'sine', 0.08);
                playSound(523, 0.1, 'sine', 0.05);
            }
        }

        function playWinSound() {
            playSound(523, 0.3, 'sine', 0.1);
            playSound(659, 0.3, 'sine', 0.08);
            playSound(784, 0.3, 'sine', 0.06);
        }

        function playAiMoveSound() {
            playSound(349, 0.2, 'triangle', 0.06);
            playSound(440, 0.15, 'triangle', 0.04);
        }

        // ===== é–‹å§‹ç•«é¢æ§åˆ¶ =====
        const startScreen = document.getElementById('start-screen');
        const gameMain = document.getElementById('game-main');
        const canvas = document.getElementById('board');
        const ctx = canvas.getContext('2d');
        const statusEl = document.getElementById('status');
        const difficultySelect = document.getElementById('difficulty');
        const restartBtn = document.getElementById('restart');
        const undoBtn = document.getElementById('undo');
        const hintBtn = document.getElementById('hint');

        const BOARD_SIZE = 15;
        const CELL_SIZE = 40;
        const OFFSET = 20;
        const RADIUS = 16;

        let board = [];
        let currentPlayer = 1; // 1: é»‘ï¼ˆç©å®¶ï¼‰ï¼Œ-1: ç™½ï¼ˆAIï¼‰
        let gameActive = true;
        let difficulty = 'medium';
        let undoUsed = false;
        let hintUsed = 0;
        const MAX_HINTS = 3;
        let moveHistory = []; // ç”¨æ–¼æ‚”æ£‹
        let hoverPos = null;
        let hintPos = null;
        
        // éŠæˆ²çµ±è¨ˆ
        let gameStats = {
            wins: 0,
            losses: 0,
            draws: 0,
            totalGames: 0,
            currentStreak: 0,
            bestStreak: 0,
            achievements: {
                firstWin: false,
                fiveWins: false,
                beatHardAI: false,
                perfectGame: false,
                hintMaster: false
            }
        };
        
        // å¾æœ¬åœ°å­˜å„²åŠ è¼‰çµ±è¨ˆæ•¸æ“š
        function loadStats() {
            const saved = localStorage.getItem('gomokuStats');
            if (saved) {
                try {
                    gameStats = JSON.parse(saved);
                } catch (e) {
                    // å¦‚æœè§£æå¤±æ•—ï¼Œä½¿ç”¨é»˜èªå€¼
                }
            }
        }
        
        // ä¿å­˜çµ±è¨ˆæ•¸æ“šåˆ°æœ¬åœ°å­˜å„²
        function saveStats() {
            localStorage.setItem('gomokuStats', JSON.stringify(gameStats));
        }
        
        // åˆå§‹åŒ–æ™‚åŠ è¼‰çµ±è¨ˆæ•¸æ“š
        loadStats();
        
        // æ›´æ–°çµ±è¨ˆé¡¯ç¤º
        function updateStatsDisplay() {
            document.getElementById('stat-wins').textContent = gameStats.wins;
            document.getElementById('stat-losses').textContent = gameStats.losses;
            document.getElementById('stat-draws').textContent = gameStats.draws;
            document.getElementById('stat-total').textContent = gameStats.totalGames;
            document.getElementById('stat-streak').textContent = gameStats.currentStreak;
            document.getElementById('stat-best-streak').textContent = gameStats.bestStreak;
            
            const winRate = gameStats.totalGames > 0 ?
                Math.round((gameStats.wins / gameStats.totalGames) * 100) : 0;
            document.getElementById('stat-win-rate').textContent = `${winRate}%`;
            
            // æ›´æ–°æˆå°±é¡¯ç¤º
            const achievementsList = document.getElementById('achievements-list');
            const achievements = [];
            if (gameStats.achievements.firstWin) achievements.push('âœ… é¦–æ¬¡å‹åˆ©');
            else achievements.push('âšª é¦–æ¬¡å‹åˆ©');
            
            if (gameStats.achievements.fiveWins) achievements.push('âœ… äº”å ´å‹åˆ©');
            else achievements.push('âšª äº”å ´å‹åˆ©');
            
            if (gameStats.achievements.beatHardAI) achievements.push('âœ… æ“Šæ•—å›°é›£AI');
            else achievements.push('âšª æ“Šæ•—å›°é›£AI');
            
            if (gameStats.achievements.perfectGame) achievements.push('âœ… å®Œç¾éŠæˆ²ï¼ˆç„¡æ‚”æ£‹ï¼‰');
            else achievements.push('âšª å®Œç¾éŠæˆ²');
            
            if (gameStats.achievements.hintMaster) achievements.push('âœ… æç¤ºå¤§å¸«ï¼ˆä¸ç”¨æç¤ºï¼‰');
            else achievements.push('âšª æç¤ºå¤§å¸«');
            
            achievementsList.innerHTML = achievements.join('<br>');
        }
        
        // æ›´æ–°éŠæˆ²çµæœçµ±è¨ˆ
        function updateGameResult(result) {
            gameStats.totalGames++;
            
            if (result === 'win') {
                gameStats.wins++;
                gameStats.currentStreak++;
                if (gameStats.currentStreak > gameStats.bestStreak) {
                    gameStats.bestStreak = gameStats.currentStreak;
                }
                
                // æˆå°±æª¢æŸ¥
                if (!gameStats.achievements.firstWin) {
                    gameStats.achievements.firstWin = true;
                    showAchievementNotification('é¦–æ¬¡å‹åˆ©ï¼', 'ğŸ‰');
                }
                
                if (gameStats.wins >= 5 && !gameStats.achievements.fiveWins) {
                    gameStats.achievements.fiveWins = true;
                    showAchievementNotification('é”æˆäº”å ´å‹åˆ©ï¼', 'ğŸ†');
                }
                
                if (difficulty === 'hard' && !gameStats.achievements.beatHardAI) {
                    gameStats.achievements.beatHardAI = true;
                    showAchievementNotification('æ“Šæ•—å›°é›£AIï¼', 'ğŸ¤–');
                }
                
            } else if (result === 'loss') {
                gameStats.losses++;
                gameStats.currentStreak = 0;
            } else if (result === 'draw') {
                gameStats.draws++;
                gameStats.currentStreak = 0;
            }
            
            // æª¢æŸ¥å®Œç¾éŠæˆ²æˆå°±ï¼ˆæ²’æœ‰ä½¿ç”¨æ‚”æ£‹ï¼‰
            if (!undoUsed && result === 'win' && !gameStats.achievements.perfectGame) {
                gameStats.achievements.perfectGame = true;
                showAchievementNotification('å®Œç¾éŠæˆ²ï¼æ²’æœ‰ä½¿ç”¨æ‚”æ£‹', 'âœ¨');
            }
            
            // æª¢æŸ¥æç¤ºå¤§å¸«æˆå°±ï¼ˆæ²’æœ‰ä½¿ç”¨æç¤ºï¼‰
            if (hintUsed === 0 && result === 'win' && !gameStats.achievements.hintMaster) {
                gameStats.achievements.hintMaster = true;
                showAchievementNotification('æç¤ºå¤§å¸«ï¼æ²’æœ‰ä½¿ç”¨æç¤º', 'ğŸ’¡');
            }
            
            saveStats();
            updateStatsDisplay();
        }
        
        // é¡¯ç¤ºæˆå°±é€šçŸ¥
        function showAchievementNotification(title, icon) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: linear-gradient(135deg, #ffd166, #ffb347);
                color: #5a3921;
                padding: 15px 20px;
                border-radius: 10px;
                box-shadow: 0 5px 15px rgba(0,0,0,0.2);
                z-index: 1001;
                animation: slideIn 0.5s ease, fadeOut 0.5s ease 2.5s forwards;
                border-left: 5px solid #d35400;
                font-weight: bold;
                max-width: 300px;
            `;
            notification.innerHTML = `<div style="font-size: 18px;">${icon} ${title}</div>
                                     <div style="font-size: 14px; opacity: 0.8;">æˆå°±å·²è§£é–ï¼</div>`;
            document.body.appendChild(notification);
            
            // æ·»åŠ CSSå‹•ç•«
            const style = document.createElement('style');
            style.textContent = `
                @keyframes slideIn {
                    from { transform: translateX(100%); opacity: 0; }
                    to { transform: translateX(0); opacity: 1; }
                }
                @keyframes fadeOut {
                    from { opacity: 1; }
                    to { opacity: 0; transform: translateX(100%); }
                }
            `;
            document.head.appendChild(style);
            
            // 3ç§’å¾Œç§»é™¤é€šçŸ¥
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, 3000);
        }
        
        // åˆå§‹åŒ–æ™‚æ›´æ–°é¡¯ç¤º
        setTimeout(updateStatsDisplay, 100);

        // é–‹å§‹éŠæˆ²å‡½æ•¸
        function startGame() {
            // æ’­æ”¾é–‹å§‹éŸ³æ•ˆ
            playSound(523, 0.3, 'sine');
            playSound(659, 0.3, 'sine');
            
            // æ·¡å‡ºé–‹å§‹ç•«é¢
            startScreen.style.opacity = '0';
            startScreen.style.transition = 'opacity 0.5s ease';
            
            setTimeout(() => {
                startScreen.style.display = 'none';
                gameMain.style.display = 'flex';
                // åˆå§‹åŒ–æ£‹ç›¤
                initBoard();
            }, 500);
        }

        // é»æ“Šé–‹å§‹ç•«é¢é–‹å§‹éŠæˆ²
        startScreen.addEventListener('click', startGame);
        
        // æŒ‰ä»»æ„éµé–‹å§‹éŠæˆ²
        document.addEventListener('keydown', (e) => {
            if (startScreen.style.display !== 'none') {
                startGame();
            }
        });

        // åˆå§‹åŒ–æ£‹ç›¤
        function initBoard() {
            board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0));
            currentPlayer = 1;
            gameActive = true;
            undoUsed = false;
            hintUsed = 0;
            moveHistory = [];
            statusEl.textContent = 'è¼ªåˆ°ä½ ï¼ˆé»‘å­ï¼‰';
            statusEl.className = '';
            hoverPos = null;
            hintPos = null;
            drawBoard();
            undoBtn.disabled = false;
            hintBtn.disabled = false;
            hintBtn.textContent = `ğŸ’¡ æç¤ºï¼ˆå‰©é¤˜ ${MAX_HINTS - hintUsed} æ¬¡ï¼‰`;
        }

        // ç•«æ£‹ç›¤
        function drawBoard() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 1.2;

            // æ ¼ç·š
            for (let i = 0; i < BOARD_SIZE; i++) {
                ctx.beginPath();
                ctx.moveTo(OFFSET, OFFSET + i * CELL_SIZE);
                ctx.lineTo(OFFSET + (BOARD_SIZE - 1) * CELL_SIZE, OFFSET + i * CELL_SIZE);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(OFFSET + i * CELL_SIZE, OFFSET);
                ctx.lineTo(OFFSET + i * CELL_SIZE, OFFSET + (BOARD_SIZE - 1) * CELL_SIZE);
                ctx.stroke();
            }

            // å®šä½é»
            const points = [[7,7], [3,3], [3,11], [11,3], [11,11]];
            ctx.fillStyle = '#5a3921';
            points.forEach(([x, y]) => {
                ctx.beginPath();
                ctx.arc(OFFSET + x * CELL_SIZE, OFFSET + y * CELL_SIZE, 3.5, 0, Math.PI * 2);
                ctx.fill();
            });

            // æ£‹å­
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    if (board[row][col] === 1) drawStone(col, row, 'black');
                    else if (board[row][col] === -1) drawStone(col, row, 'white');
                }
            }
            
            // é«˜äº®æœ€å¾Œä¸€æ­¥
            if (moveHistory.length > 0) {
                const lastMove = moveHistory[moveHistory.length - 1];
                const {row, col} = lastMove;
                const x = OFFSET + col * CELL_SIZE;
                const y = OFFSET + row * CELL_SIZE;
                
                ctx.strokeStyle = lastMove.player === 1 ? '#ff9900' : '#0099ff';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(x, y, RADIUS + 2, 0, Math.PI * 2);
                ctx.stroke();
                ctx.lineWidth = 1.5;
            }

            // æ‡¸åœé è¦½
            if (hoverPos && currentPlayer === 1 && gameActive) {
                const [col, row] = hoverPos;
                if (board[row][col] === 0) {
                    ctx.globalAlpha = 0.5;
                    drawStone(col, row, 'black');
                    ctx.globalAlpha = 1.0;
                }
            }

            // æç¤ºé¡¯ç¤º
            if (hintPos && currentPlayer === 1 && gameActive) {
                const [col, row] = hintPos;
                if (board[row][col] === 0) {
                    ctx.globalAlpha = 0.7;
                    ctx.fillStyle = '#ff9900';
                    ctx.beginPath();
                    const x = OFFSET + col * CELL_SIZE;
                    const y = OFFSET + row * CELL_SIZE;
                    ctx.arc(x, y, RADIUS + 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                    
                    // é–ƒçˆæ•ˆæœ
                    const time = Date.now() / 200;
                    ctx.globalAlpha = 0.3 + 0.2 * Math.sin(time);
                    ctx.fillStyle = '#ffff00';
                    ctx.beginPath();
                    ctx.arc(x, y, RADIUS - 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                }
            }
        }

        function drawStone(col, row, color, animate = false) {
            const x = OFFSET + col * CELL_SIZE;
            const y = OFFSET + row * CELL_SIZE;
            
            // å¦‚æœéœ€è¦å‹•ç•«ï¼Œå…ˆä¿å­˜ä¸Šä¸‹æ–‡ç‹€æ…‹
            if (animate) {
                ctx.save();
                ctx.beginPath();
                ctx.arc(x, y, RADIUS, 0, Math.PI * 2);
                ctx.clip();
                
                // å‹•ç•«æ•ˆæœï¼šå¾å°åˆ°å¤§
                const scale = 1; // å¯ä»¥æ ¹æ“šéœ€è¦èª¿æ•´å‹•ç•«
                ctx.translate(x, y);
                ctx.scale(scale, scale);
                ctx.translate(-x, -y);
            }
            
            ctx.beginPath();
            ctx.arc(x, y, RADIUS, 0, Math.PI * 2);
            ctx.shadowColor = 'rgba(0,0,0,0.3)';
            ctx.shadowBlur = 5;
            ctx.fillStyle = color;
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1.5;
            ctx.stroke();

            // å…‰æ¾¤
            if (color === 'white') {
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(x - 5, y - 5, RADIUS / 3, 0, Math.PI * 2);
                ctx.fill();
            } else {
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.arc(x - 4, y - 4, RADIUS / 4, 0, Math.PI * 2);
                ctx.fill();
            }
            
            if (animate) {
                ctx.restore();
            }
        }
        
        // ç¹ªè£½å¸¶æœ‰å‹•ç•«çš„æ£‹å­
        function drawStoneWithAnimation(col, row, color) {
            const x = OFFSET + col * CELL_SIZE;
            const y = OFFSET + row * CELL_SIZE;
            
            // ç°¡å–®çš„ç¸®æ”¾å‹•ç•«
            let scale = 0;
            const animate = () => {
                ctx.clearRect(x - RADIUS - 2, y - RADIUS - 2, RADIUS * 2 + 4, RADIUS * 2 + 4);
                
                // é‡ç¹ªèƒŒæ™¯
                ctx.fillStyle = '#f0e0c0';
                ctx.fillRect(x - RADIUS - 2, y - RADIUS - 2, RADIUS * 2 + 4, RADIUS * 2 + 4);
                
                // ç¹ªè£½æ ¼ç·šï¼ˆå±€éƒ¨ï¼‰
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = 1.2;
                ctx.beginPath();
                ctx.moveTo(OFFSET, y);
                ctx.lineTo(OFFSET + (BOARD_SIZE - 1) * CELL_SIZE, y);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(x, OFFSET);
                ctx.lineTo(x, OFFSET + (BOARD_SIZE - 1) * CELL_SIZE);
                ctx.stroke();
                
                // ç¹ªè£½ç¸®æ”¾ä¸­çš„æ£‹å­
                ctx.save();
                ctx.translate(x, y);
                ctx.scale(scale, scale);
                ctx.translate(-x, -y);
                
                ctx.beginPath();
                ctx.arc(x, y, RADIUS, 0, Math.PI * 2);
                ctx.shadowColor = 'rgba(0,0,0,0.3)';
                ctx.shadowBlur = 5;
                ctx.fillStyle = color;
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1.5;
                ctx.stroke();
                
                // å…‰æ¾¤
                if (color === 'white') {
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(x - 5, y - 5, RADIUS / 3, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    ctx.fillStyle = '#333';
                    ctx.beginPath();
                    ctx.arc(x - 4, y - 4, RADIUS / 4, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
                
                scale += 0.1;
                if (scale < 1) {
                    requestAnimationFrame(animate);
                } else {
                    // å‹•ç•«å®Œæˆï¼Œé‡ç¹ªå®Œæ•´æ£‹ç›¤
                    drawBoard();
                }
            };
            animate();
        }

        // å‹åˆ©æª¢æŸ¥
        function checkWin(row, col, player) {
            const dirs = [[0,1],[1,0],[1,1],[1,-1]];
            for (const [dx, dy] of dirs) {
                let count = 1;
                for (let i = 1; i < 5; i++) {
                    const r = row + i * dx, c = col + i * dy;
                    if (r < 0 || r >= BOARD_SIZE || c < 0 || c >= BOARD_SIZE || board[r][c] !== player) break;
                    count++;
                }
                for (let i = 1; i < 5; i++) {
                    const r = row - i * dx, c = col - i * dy;
                    if (r < 0 || r >= BOARD_SIZE || c < 0 || c >= BOARD_SIZE || board[r][c] !== player) break;
                    count++;
                }
                if (count >= 5) return true;
            }
            return false;
        }

        function isBoardFull() {
            return board.every(row => row.every(cell => cell !== 0));
        }

        // æç¤ºåŠŸèƒ½
        function showHint() {
            if (!gameActive || currentPlayer !== 1 || hintUsed >= MAX_HINTS) return;
            
            // ä½¿ç”¨è²ªå¿ƒç®—æ³•æ‰¾åˆ°æœ€ä½³ä½ç½®
            const bestMove = aiGreedy();
            if (!bestMove) return;
            
            const [row, col] = bestMove;
            hintPos = [col, row];
            hintUsed++;
            hintBtn.textContent = `ğŸ’¡ æç¤ºï¼ˆå‰©é¤˜ ${MAX_HINTS - hintUsed} æ¬¡ï¼‰`;
            
            if (hintUsed >= MAX_HINTS) {
                hintBtn.disabled = true;
            }
            
            // æ’­æ”¾æç¤ºéŸ³æ•ˆ
            playSound(784, 0.3, 'sine', 0.08);
            playSound(659, 0.2, 'sine', 0.05);
            
            drawBoard();
            
            // 5ç§’å¾Œæ¸…é™¤æç¤º
            setTimeout(() => {
                hintPos = null;
                drawBoard();
            }, 5000);
        }

        // è½å­
        function makeMove(col, row) {
            if (!gameActive || board[row][col] !== 0) return false;

            // æ¸…é™¤æç¤º
            hintPos = null;

            // è¨˜éŒ„æ­·å²ï¼ˆç”¨æ–¼æ‚”æ£‹ï¼‰
            moveHistory.push({row, col, player: currentPlayer});

            // æ’­æ”¾è½å­éŸ³æ•ˆ
            playStoneSound(currentPlayer);

            board[row][col] = currentPlayer;
            drawBoard();

            if (checkWin(row, col, currentPlayer)) {
                const winner = currentPlayer === 1 ? 'ä½ ï¼ˆé»‘å­ï¼‰' : 'AIï¼ˆç™½å­ï¼‰';
                statusEl.textContent = `ğŸ‰ ${winner} å‹åˆ©ï¼`;
                statusEl.style.color = '#d35400';
                gameActive = false;
                playWinSound();
                
                // æ›´æ–°çµ±è¨ˆ
                if (currentPlayer === 1) {
                    updateGameResult('win');
                    celebrateWin();
                } else {
                    updateGameResult('loss');
                }
                
                return true;
            }

            if (isBoardFull()) {
                statusEl.textContent = 'â›” å¹³å±€ï¼';
                statusEl.style.color = '#7f8c8d';
                gameActive = false;
                playSound(440, 0.3);
                
                // æ›´æ–°çµ±è¨ˆ
                updateGameResult('draw');
                
                return true;
            }

            currentPlayer *= -1;
            if (currentPlayer === -1 && gameActive) {
                statusEl.textContent = 'AI æ€è€ƒä¸­... ğŸ¤”';
                statusEl.className = 'thinking';
                let delay;
                switch (difficulty) {
                    case 'easy': delay = 800; break;
                    case 'medium': delay = 400; break;
                    case 'hard': delay = 600; break;
                    case 'expert': delay = 800; break;
                    case 'impossible': delay = 1200; break;
                    default: delay = 400;
                }
                setTimeout(aiMove, delay);
            } else {
                statusEl.textContent = 'è¼ªåˆ°ä½ ï¼ˆé»‘å­ï¼‰';
                statusEl.className = '';
            }
            return true;
        }

        // æ…¶ç¥å‹•ç•«
        function celebrateWin() {
            const particles = [];
            for (let i = 0; i < 100; i++) {
                particles.push({
                    x: canvas.width / 2,
                    y: canvas.height / 2,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8 - 4,
                    life: 60,
                    color: ['#ff9ff3', '#feca57', '#48dbfb', '#1dd1a1'][Math.floor(Math.random() * 4)]
                });
            }

            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawBoard(); // é‡ç¹ªæ£‹ç›¤èˆ‡æ£‹å­

                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.1;
                    p.life--;
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = p.life / 60;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1.0;

                if (particles.some(p => p.life > 0)) {
                    requestAnimationFrame(animate);
                } else {
                    drawBoard(); // æœ€å¾Œæ¢å¾©
                }
            }
            animate();
        }

        // ===== AI é‚è¼¯ï¼ˆä¿ç•™åŸé‚è¼¯ï¼Œåƒ…å¾®èª¿ï¼‰=====
        function aiRandom() {
            const empty = [];
            for (let r = 0; r < BOARD_SIZE; r++)
                for (let c = 0; c < BOARD_SIZE; c++)
                    if (board[r][c] === 0) empty.push([r, c]);
            return empty.length ? empty[Math.floor(Math.random() * empty.length)] : null;
        }

        function countPattern(row, col, player, need) {
            const dirs = [[0,1],[1,0],[1,1],[1,-1]];
            for (const [dx, dy] of dirs) {
                let count = 1, openEnds = 0;
                for (let i = 1; i <= need; i++) {
                    const r = row + i * dx, c = col + i * dy;
                    if (r < 0 || r >= BOARD_SIZE || c < 0 || c >= BOARD_SIZE) break;
                    if (board[r][c] === player) count++;
                    else if (board[r][c] === 0) { openEnds++; break; }
                    else break;
                }
                for (let i = 1; i <= need; i++) {
                    const r = row - i * dx, c = col - i * dy;
                    if (r < 0 || r >= BOARD_SIZE || c < 0 || c >= BOARD_SIZE) break;
                    if (board[r][c] === player) count++;
                    else if (board[r][c] === 0) { openEnds++; break; }
                    else break;
                }
                if (count >= need && openEnds >= 1) return true;
            }
            return false;
        }

        function aiGreedy() {
            const threats = [
                { player: -1, need: 4, score: 10000 },
                { player: 1,  need: 4, score: 9000  },
                { player: -1, need: 3, score: 1000  },
                { player: 1,  need: 3, score: 900   },
                { player: -1, need: 2, score: 100   },
                { player: 1,  need: 2, score: 90    }
            ];

            let bestScore = -1;
            let bestMove = null;

            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (board[r][c] !== 0) continue;
                    let score = 0;
                    for (const t of threats) {
                        if (countPattern(r, c, t.player, t.need)) score += t.score;
                    }
                    const centerDist = Math.abs(r - 7) + Math.abs(c - 7);
                    score += (8 - Math.min(7, centerDist)) * 2;
                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = [r, c];
                    }
                }
            }
            return bestMove;
        }

        function evaluateBoard() {
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (board[r][c] !== 0 && checkWin(r, c, board[r][c])) {
                        return board[r][c] === -1 ? 100000 : -100000;
                    }
                }
            }
            let score = 0;
            const dirs = [[0,1],[1,0],[1,1],[1,-1]];
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (board[r][c] === 0) continue;
                    const player = board[r][c];
                    const mult = player === -1 ? 1 : -1;
                    for (const [dx, dy] of dirs) {
                        let count = 1;
                        for (let i = 1; i < 5; i++) {
                            const nr = r + i * dx, nc = c + i * dy;
                            if (nr < 0 || nr >= BOARD_SIZE || nc < 0 || nc >= BOARD_SIZE) break;
                            if (board[nr][nc] === player) count++;
                            else if (board[nr][nc] !== 0) break;
                            else break;
                        }
                        for (let i = 1; i < 5; i++) {
                            const nr = r - i * dx, nc = c - i * dy;
                            if (nr < 0 || nr >= BOARD_SIZE || nc < 0 || nc >= BOARD_SIZE) break;
                            if (board[nr][nc] === player) count++;
                            else if (board[nr][nc] !== 0) break;
                            else break;
                        }
                        if (count >= 2) score += mult * Math.pow(10, count - 1);
                    }
                }
            }
            return score;
        }

        function aiMinimax(depth) {
            let bestScore = -Infinity;
            let bestMove = null;
            const empty = [];
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (board[r][c] === 0) {
                        let near = false;
                        for (let dr = -2; dr <= 2; dr++) {
                            for (let dc = -2; dc <= 2; dc++) {
                                const nr = r + dr, nc = c + dc;
                                if (nr >= 0 && nr < BOARD_SIZE && nc >=0 && nc < BOARD_SIZE && board[nr][nc] !== 0) {
                                    near = true; break;
                                }
                            }
                            if (near) break;
                        }
                        if (near || empty.length < 20) empty.push([r, c]);
                    }
                }
            }
            for (const [r, c] of empty) {
                board[r][c] = -1;
                const score = minimax(depth - 1, -Infinity, Infinity, false);
                board[r][c] = 0;
                if (score > bestScore) {
                    bestScore = score;
                    bestMove = [r, c];
                }
            }
            return bestMove;
        }

        function minimax(depth, alpha, beta, maximizing) {
            const winner = evaluateBoard();
            if (depth === 0 || Math.abs(winner) === 100000) return winner;

            const empty = [];
            for (let r = 0; r < BOARD_SIZE; r++)
                for (let c = 0; c < BOARD_SIZE; c++)
                    if (board[r][c] === 0) empty.push([r, c]);

            if (maximizing) {
                let maxEval = -Infinity;
                for (const [r, c] of empty) {
                    board[r][c] = -1;
                    const eval = minimax(depth - 1, alpha, beta, false);
                    board[r][c] = 0;
                    maxEval = Math.max(maxEval, eval);
                    alpha = Math.max(alpha, eval);
                    if (beta <= alpha) break;
                }
                return maxEval;
            } else {
                let minEval = Infinity;
                for (const [r, c] of empty) {
                    board[r][c] = 1;
                    const eval = minimax(depth - 1, alpha, beta, true);
                    board[r][c] = 0;
                    minEval = Math.min(minEval, eval);
                    beta = Math.min(beta, eval);
                    if (beta <= alpha) break;
                }
                return minEval;
            }
        }

        function aiMove() {
            if (!gameActive) return;
            let move;
            switch (difficulty) {
                case 'easy': move = aiRandom(); break;
                case 'medium': move = aiGreedy(); break;
                case 'hard': move = aiMinimax(2); break;
                case 'expert': move = aiMinimax(3); break;
                case 'impossible': move = aiMinimax(4); break;
            }
            if (!move) move = aiRandom();
            if (move) {
                const [row, col] = move;
                // æ’­æ”¾AIç§»å‹•éŸ³æ•ˆ
                playAiMoveSound();
                makeMove(col, row);
            }
        }

        // ===== äº‹ä»¶è™•ç† =====
        canvas.addEventListener('mousemove', (e) => {
            if (!gameActive || currentPlayer !== 1) return;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const col = Math.round((x - OFFSET) / CELL_SIZE);
            const row = Math.round((y - OFFSET) / CELL_SIZE);
            if (col >= 0 && col < BOARD_SIZE && row >= 0 && row < BOARD_SIZE) {
                hoverPos = [col, row];
                drawBoard();
            }
        });

        canvas.addEventListener('click', (e) => {
            if (!gameActive || currentPlayer !== 1) return;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const col = Math.round((x - OFFSET) / CELL_SIZE);
            const row = Math.round((y - OFFSET) / CELL_SIZE);
            if (col >= 0 && col < BOARD_SIZE && row >= 0 && row < BOARD_SIZE) {
                makeMove(col, row);
            }
        });

        difficultySelect.addEventListener('change', () => {
            difficulty = difficultySelect.value;
        });

        restartBtn.addEventListener('click', initBoard);

        undoBtn.addEventListener('click', () => {
            if (undoUsed || !gameActive || moveHistory.length === 0 || currentPlayer !== 1) return;
            // æ’¤éŠ·ç©å®¶æœ€å¾Œä¸€æ­¥
            while (moveHistory.length > 0) {
                const last = moveHistory.pop();
                if (last.player === 1) {
                    board[last.row][last.col] = 0;
                    undoUsed = true;
                    undoBtn.disabled = true;
                    gameActive = true;
                    currentPlayer = 1;
                    statusEl.textContent = 'è¼ªåˆ°ä½ ï¼ˆé»‘å­ï¼‰';
                    statusEl.className = '';
                    drawBoard();
                    break;
                }
            }
        });

        hintBtn.addEventListener('click', showHint);
        
        // è©³ç´°çµ±è¨ˆæŒ‰éˆ•
        document.getElementById('show-stats').addEventListener('click', () => {
            alert(`è©³ç´°çµ±è¨ˆï¼š
å‹å ´: ${gameStats.wins}
æ•—å ´: ${gameStats.losses}
å¹³å±€: ${gameStats.draws}
ç¸½éŠæˆ²æ•¸: ${gameStats.totalGames}
ç•¶å‰é€£å‹: ${gameStats.currentStreak}
æœ€ä½³é€£å‹: ${gameStats.bestStreak}
å‹ç‡: ${gameStats.totalGames > 0 ? Math.round((gameStats.wins / gameStats.totalGames) * 100) : 0}%

æˆå°±:
${gameStats.achievements.firstWin ? 'âœ…' : 'âšª'} é¦–æ¬¡å‹åˆ©
${gameStats.achievements.fiveWins ? 'âœ…' : 'âšª'} äº”å ´å‹åˆ©
${gameStats.achievements.beatHardAI ? 'âœ…' : 'âšª'} æ“Šæ•—å›°é›£AI
${gameStats.achievements.perfectGame ? 'âœ…' : 'âšª'} å®Œç¾éŠæˆ²ï¼ˆç„¡æ‚”æ£‹ï¼‰
${gameStats.achievements.hintMaster ? 'âœ…' : 'âšª'} æç¤ºå¤§å¸«ï¼ˆä¸ç”¨æç¤ºï¼‰
            `);
        });

        // éŠæˆ²å¾é–‹å§‹ç•«é¢é–‹å§‹ï¼Œä¸è‡ªå‹•åˆå§‹åŒ–æ£‹ç›¤
        // initBoard(); // å·²ç§»é™¤ï¼Œç­‰å¾…ç©å®¶é–‹å§‹éŠæˆ²
    </script>
</body>
</html>