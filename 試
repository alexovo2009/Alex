<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è²ªé£Ÿè›‡éŠæˆ²</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #000;
            font-family: 'Arial', sans-serif;
            color: white;
            overflow: hidden;
        }
        
        #game-container {
            position: relative;
            width: 400px;
            text-align: center;
        }
        
        #game-board {
            background-color: #000;
            border: 2px solid #333;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
            transition: box-shadow 0.3s;
        }
        .pulse-border {
            animation: pulseGlow 2s infinite alternate;
        }
        @keyframes pulseGlow {
            from { box-shadow: 0 0 20px rgba(0, 255, 0, 0.3); }
            to { box-shadow: 0 0 35px rgba(0, 255, 0, 0.6); }
        }

        #score-info {
            margin-top: 15px;
            font-size: 20px;
            display: flex;
            justify-content: space-around;
        }
        #score, #high-score {
            color: #4CAF50;
            text-shadow: 0 0 8px rgba(76, 175, 80, 0.7);
        }
        #high-score {
            color: #FFD700;
        }

        #difficulty-selector {
            margin: 10px 0;
        }
        #difficulty-selector label {
            margin-right: 10px;
            color: #aaa;
        }
        #difficulty {
            background: #333;
            color: white;
            border: 1px solid #555;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 16px;
        }

        #instructions {
            margin-top: 8px;
            color: #aaa;
            font-size: 14px;
        }

        #start-screen, #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.85);
            padding: 25px;
            border-radius: 10px;
            border: 2px solid #4CAF50;
            z-index: 10;
            width: 85%;
            text-align: center;
        }
        #start-screen h2 {
            color: #4CAF50;
            margin-top: 0;
        }
        #start-screen {
            display: block;
        }
        #game-over {
            display: none;
            border-color: #f44336;
        }
        #game-over h2 {
            color: #f44336;
            margin-top: 0;
            text-shadow: 0 0 10px rgba(244, 67, 54, 0.7);
        }

        #feedback {
            font-size: 18px;
            margin: 15px 0;
            min-height: 24px;
            line-height: 1.4;
        }
        .feedback-great { color: #4CAF50; text-shadow: 0 0 10px rgba(76, 175, 80, 0.8); }
        .feedback-good { color: #8BC34A; }
        .feedback-ok { color: #FFC107; }
        .feedback-bad { color: #FF9800; }
        .feedback-terrible { color: #f44336; }
        .feedback-legend { 
            color: gold; 
            font-weight: bold;
            text-shadow: 0 0 15px gold;
            animation: glow 1.5s infinite alternate;
        }
        @keyframes glow {
            from { text-shadow: 0 0 10px gold; }
            to { text-shadow: 0 0 25px gold, 0 0 30px gold; }
        }

        #final-score {
            font-size: 22px;
            margin: 10px 0;
            color: #4CAF50;
        }
        
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 12px 25px;
            font-size: 18px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 10px;
        }
        button:hover {
            background-color: #45a049;
            box-shadow: 0 0 15px rgba(76, 175, 80, 0.7);
        }
        #restart-btn {
            background-color: #f44336;
        }
        #restart-btn:hover {
            background-color: #d32f2f;
            box-shadow: 0 0 15px rgba(244, 67, 54, 0.7);
        }

        #pause-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 32px;
            font-weight: bold;
            display: none;
            z-index: 9;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-board" width="400" height="400"></canvas>
        <div id="pause-overlay">æš«åœä¸­...<br>æŒ‰ç©ºæ ¼ç¹¼çºŒ</div>
        
        <div id="score-info">
            <div id="score">åˆ†æ•¸: 0</div>
            <div id="high-score">æœ€é«˜åˆ†: 0</div>
        </div>

        <div id="difficulty-selector">
            <label for="difficulty">é›£åº¦:</label>
            <select id="difficulty">
                <option value="easy">ç°¡å–®</option>
                <option value="medium" selected>ä¸­ç´š</option>
                <option value="hard">å›°é›£</option>
            </select>
        </div>

        <div id="instructions">æ–¹å‘éµæ§åˆ¶ï½œç©ºæ ¼éµæš«åœ</div>
        
        <div id="start-screen">
            <h2>ğŸ è²ªé£Ÿè›‡éŠæˆ²</h2>
            <p>åƒæ‰ç´…è‰²è˜‹æœä¾†æˆé•·ï¼</p>
            <button id="start-btn">é–‹å§‹éŠæˆ²ï¼</button>
        </div>

        <div id="game-over">
            <h2>éŠæˆ²çµæŸ!</h2>
            <div id="final-score">åˆ†æ•¸: 0</div>
            <div id="feedback"></div>
            <button id="restart-btn">å†ä¾†ä¸€å±€ï¼</button>
        </div>
    </div>

    <script>
        // éŸ³æ•ˆæ¨¡æ“¬ï¼ˆç°¡å–® beepï¼‰
        function playSound(type) {
            try {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.connect(gain);
                gain.connect(ctx.destination);
                switch(type) {
                    case 'eat': 
                        osc.frequency.value = 400;
                        gain.gain.value = 0.1;
                        break;
                    case 'special':
                        osc.frequency.value = 600;
                        gain.gain.value = 0.15;
                        break;
                    case 'gameOver':
                        osc.frequency.value = 200;
                        gain.gain.value = 0.2;
                        break;
                    default:
                        return;
                }
                osc.type = 'sine';
                osc.start();
                setTimeout(() => { osc.stop(); }, 150);
            } catch(e) {}
        }

        // éŠæˆ²è®Šæ•¸
        const canvas = document.getElementById('game-board');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const highScoreDisplay = document.getElementById('high-score');
        const finalScoreDisplay = document.getElementById('final-score');
        const feedbackDisplay = document.getElementById('feedback');
        const gameOverScreen = document.getElementById('game-over');
        const startScreen = document.getElementById('start-screen');
        const restartBtn = document.getElementById('restart-btn');
        const startBtn = document.getElementById('start-btn');
        const pauseOverlay = document.getElementById('pause-overlay');
        const difficultySelect = document.getElementById('difficulty');
        
        // é›£åº¦è¨­å®š
        const difficultySettings = {
            easy: { initialSpeed: 180, speedIncrease: 5, scoreThreshold: 100, obstacleChance: 0 },
            medium: { initialSpeed: 120, speedIncrease: 10, scoreThreshold: 50, obstacleChance: 0.02 },
            hard: { initialSpeed: 80, speedIncrease: 15, scoreThreshold: 30, obstacleChance: 0.05 }
        };

        const gridSize = 20;
        const gridWidth = canvas.width / gridSize;
        const gridHeight = canvas.height / gridSize;
        
        let snake = [];
        let food = {};
        let specialFood = null; // é‡‘è‰²æ˜Ÿæ˜Ÿ
        let obstacles = [];
        let direction = 'right';
        let nextDirection = 'right';
        let score = 0;
        let highScore = parseInt(localStorage.getItem('snakeHighScore')) || 0;
        let gameSpeed = 120;
        let gameRunning = false;
        let gamePaused = false;
        let gameLoop;
        let currentDifficulty = 'medium';
        let specialFoodTimer = 0;

        highScoreDisplay.textContent = `æœ€é«˜åˆ†: ${highScore}`;
        
        function initGame() {
            currentDifficulty = difficultySelect.value;
            const settings = difficultySettings[currentDifficulty];
            
            snake = [
                {x: 10, y: 10},
                {x: 9, y: 10},
                {x: 8, y: 10}
            ];
            
            generateFood();
            specialFood = null;
            specialFoodTimer = 0;
            obstacles = [];
            
            // ç”Ÿæˆéšœç¤™ç‰©ï¼ˆåƒ…ä¸­ã€é«˜é›£åº¦ï¼‰
            if (settings.obstacleChance > 0) {
                const obstacleCount = Math.floor((gridWidth * gridHeight) * settings.obstacleChance);
                for (let i = 0; i < obstacleCount; i++) {
                    let obs;
                    let valid = false;
                    while (!valid) {
                        obs = {
                            x: Math.floor(Math.random() * gridWidth),
                            y: Math.floor(Math.random() * gridHeight)
                        };
                        // ä¸åœ¨è›‡èº«ä¸Šã€ä¸åœ¨é£Ÿç‰©ä¸Šã€ä¸é‡è¤‡
                        if (
                            !snake.some(s => s.x === obs.x && s.y === obs.y) &&
                            food.x !== obs.x && food.y !== obs.y &&
                            !obstacles.some(o => o.x === obs.x && o.y === obs.y)
                        ) {
                            obstacles.push(obs);
                            valid = true;
                        }
                    }
                }
            }
            
            direction = 'right';
            nextDirection = 'right';
            score = 0;
            gameSpeed = settings.initialSpeed;
            gameRunning = true;
            gamePaused = false;
            
            scoreDisplay.textContent = `åˆ†æ•¸: ${score}`;
            highScoreDisplay.textContent = `æœ€é«˜åˆ†: ${highScore}`;
            gameOverScreen.style.display = 'none';
            startScreen.style.display = 'none';
            pauseOverlay.style.display = 'none';
            canvas.classList.add('pulse-border');
            
            if (gameLoop) clearInterval(gameLoop);
            gameLoop = setInterval(update, gameSpeed);
        }
        
        function generateFood() {
            let newFood;
            let valid = false;
            while (!valid) {
                newFood = {
                    x: Math.floor(Math.random() * gridWidth),
                    y: Math.floor(Math.random() * gridHeight)
                };
                valid = true;
                // æª¢æŸ¥æ˜¯å¦èˆ‡è›‡ã€éšœç¤™ç‰©é‡ç–Š
                for (let segment of snake) {
                    if (segment.x === newFood.x && segment.y === newFood.y) {
                        valid = false;
                        break;
                    }
                }
                if (valid) {
                    for (let obs of obstacles) {
                        if (obs.x === newFood.x && obs.y === newFood.y) {
                            valid = false;
                            break;
                        }
                    }
                }
            }
            food = newFood;
        }

        function generateSpecialFood() {
            if (specialFood) return; // å·²å­˜åœ¨
            let newFood;
            let valid = false;
            while (!valid) {
                newFood = {
                    x: Math.floor(Math.random() * gridWidth),
                    y: Math.floor(Math.random() * gridHeight)
                };
                valid = true;
                for (let segment of snake) {
                    if (segment.x === newFood.x && segment.y === newFood.y) {
                        valid = false;
                        break;
                    }
                }
                if (valid && food.x === newFood.x && food.y === newFood.y) valid = false;
                if (valid) {
                    for (let obs of obstacles) {
                        if (obs.x === newFood.x && obs.y === newFood.y) {
                            valid = false;
                            break;
                        }
                    }
                }
            }
            specialFood = newFood;
        }
        
        function update() {
            if (gamePaused) return;
            
            direction = nextDirection;
            const head = {...snake[0]};
            
            switch (direction) {
                case 'up': head.y--; break;
                case 'down': head.y++; break;
                case 'left': head.x--; break;
                case 'right': head.x++; break;
            }
            
            if (checkCollision(head)) {
                playSound('gameOver');
                gameOver();
                return;
            }
            
            snake.unshift(head);
            
            let ateSomething = false;
            
            // æª¢æŸ¥æ˜¯å¦åƒåˆ°æ™®é€šé£Ÿç‰©
            if (head.x === food.x && head.y === food.y) {
                score += 10;
                playSound('eat');
                generateFood();
                ateSomething = true;
            }
            
            // æª¢æŸ¥æ˜¯å¦åƒåˆ°ç‰¹æ®Šé£Ÿç‰©
            if (specialFood && head.x === specialFood.x && head.y === specialFood.y) {
                score += 30;
                playSound('special');
                specialFood = null;
                // çŸ­æš«åŠ é€Ÿ
                let tempSpeed = Math.max(50, gameSpeed - 30);
                clearInterval(gameLoop);
                gameLoop = setInterval(update, tempSpeed);
                setTimeout(() => {
                    if (gameRunning) {
                        clearInterval(gameLoop);
                        gameLoop = setInterval(update, gameSpeed);
                    }
                }, 1500);
                ateSomething = true;
            }
            
            if (!ateSomething) {
                snake.pop();
            }
            
            // ç‰¹æ®Šé£Ÿç‰©è¨ˆæ™‚ï¼ˆæ¯ 50 åˆ†å‡ºç¾ï¼‰
            specialFoodTimer++;
            if (score >= 50 && specialFoodTimer % (300) === 0 && !specialFood) {
                generateSpecialFood();
            }
            
            // é›£åº¦åŠ é€Ÿ
            const settings = difficultySettings[currentDifficulty];
            if (score > 0 && score % settings.scoreThreshold === 0 && gameSpeed > 50) {
                const oldSpeed = gameSpeed;
                gameSpeed = Math.max(50, gameSpeed - settings.speedIncrease);
                if (gameSpeed < oldSpeed) {
                    clearInterval(gameLoop);
                    gameLoop = setInterval(update, gameSpeed);
                }
            }
            
            scoreDisplay.textContent = `åˆ†æ•¸: ${score}`;
            draw();
        }
        
        function checkCollision(pos) {
            // é‚Šç•Œç¢°æ’
            if (pos.x < 0 || pos.x >= gridWidth || pos.y < 0 || pos.y >= gridHeight) {
                return true;
            }
            // è‡ªæ’
            for (let i = 1; i < snake.length; i++) {
                if (pos.x === snake[i].x && pos.y === snake[i].y) {
                    return true;
                }
            }
            // éšœç¤™ç‰©ç¢°æ’
            for (let obs of obstacles) {
                if (pos.x === obs.x && pos.y === obs.y) {
                    return true;
                }
            }
            return false;
        }
        
        function draw() {
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ç¶²æ ¼
            ctx.strokeStyle = '#111';
            ctx.lineWidth = 0.5;
            for (let x = 0; x <= canvas.width; x += gridSize) {
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
            }
            for (let y = 0; y <= canvas.height; y += gridSize) {
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
            }
            
            // éšœç¤™ç‰©
            ctx.fillStyle = '#555';
            for (let obs of obstacles) {
                ctx.fillRect(obs.x * gridSize, obs.y * gridSize, gridSize - 1, gridSize - 1);
            }
            
            // è›‡
            snake.forEach((segment, index) => {
                if (index === 0) {
                    ctx.fillStyle = '#4CAF50';
                } else {
                    const ratio = index / snake.length;
                    const r = Math.floor(46 + (76-46) * (1 - ratio));
                    const g = Math.floor(125 + (175-125) * (1 - ratio));
                    const b = Math.floor(50 + (80-50) * (1 - ratio));
                    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                }
                ctx.fillRect(segment.x * gridSize, segment.y * gridSize, gridSize - 1, gridSize - 1);
            });
            
            // æ™®é€šé£Ÿç‰©ï¼ˆè˜‹æœï¼‰
            ctx.fillStyle = '#f44336';
            ctx.beginPath();
            ctx.arc(food.x * gridSize + gridSize/2, food.y * gridSize + gridSize/2, gridSize/2 - 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(food.x * gridSize + gridSize/2 - 2, food.y * gridSize - 2, 4, 6);
            ctx.fillStyle = '#4CAF50';
            ctx.beginPath();
            ctx.moveTo(food.x * gridSize + gridSize/2 + 3, food.y * gridSize + 2);
            ctx.lineTo(food.x * gridSize + gridSize/2 + 8, food.y * gridSize - 2);
            ctx.lineTo(food.x * gridSize + gridSize/2 + 4, food.y * gridSize - 4);
            ctx.closePath();
            ctx.fill();
            
            // ç‰¹æ®Šé£Ÿç‰©ï¼ˆé‡‘è‰²æ˜Ÿæ˜Ÿï¼‰
            if (specialFood) {
                ctx.fillStyle = 'gold';
                ctx.beginPath();
                const cx = specialFood.x * gridSize + gridSize/2;
                const cy = specialFood.y * gridSize + gridSize/2;
                const r = gridSize/2 - 3;
                for (let i = 0; i < 5; i++) {
                    const angle = (i * 4 * Math.PI / 5) - Math.PI/2;
                    const x = cx + r * Math.cos(angle);
                    const y = cy + r * Math.sin(angle);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                    const innerAngle = angle + 2 * Math.PI / 5;
                    const ix = cx + (r * 0.4) * Math.cos(innerAngle);
                    const iy = cy + (r * 0.4) * Math.sin(innerAngle);
                    ctx.lineTo(ix, iy);
                }
                ctx.closePath();
                ctx.fill();
            }
        }
        
        function gameOver() {
            gameRunning = false;
            clearInterval(gameLoop);
            canvas.classList.remove('pulse-border');
            
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('snakeHighScore', highScore);
            }
            highScoreDisplay.textContent = `æœ€é«˜åˆ†: ${highScore}`;
            finalScoreDisplay.textContent = `åˆ†æ•¸: ${score}`;
            
            const feedback = getFeedback(score, currentDifficulty);
            feedbackDisplay.innerHTML = feedback.text;
            feedbackDisplay.className = feedback.className;
            
            gameOverScreen.style.display = 'block';
        }
        
        function getFeedback(score, difficulty) {
            const dName = { easy: 'ç°¡å–®', medium: 'ä¸­ç´š', hard: 'å›°é›£' }[difficulty] || 'ä¸­ç´š';
            if (score === highScore && score > 0) {
                return { text: `ğŸ† ç ´ç´€éŒ„å•¦ï¼ä½ åˆ·æ–°äº†${dName}æ¨¡å¼çš„æœ€é«˜åˆ†ï¼`, className: 'feedback-legend' };
            }
            
            let normalizedScore = score;
            if (difficulty === 'easy') normalizedScore = Math.floor(score * 0.7);
            if (difficulty === 'hard') normalizedScore = Math.floor(score * 1.3);

            if (normalizedScore >= 300) {
                return { text: `ğŸ ä½ ç°¡ç›´æ˜¯è›‡ç¥è½‰ä¸–ï¼å»ºè­°ç›´æ¥å»åƒåŠ è²ªé£Ÿè›‡å¥§é‹ï½`, className: 'feedback-legend' };
            } else if (normalizedScore >= 150) {
                return { text: `ğŸ¯ å¤ªå¼·äº†ï¼ä½ çš„è›‡åƒè£äº†GPSï¼Œç²¾æº–å¾—å¯æ€•ï¼`, className: 'feedback-great' };
            } else if (normalizedScore >= 80) {
                return { text: `ğŸ‘ è¡¨ç¾ä¸éŒ¯ï¼å†ç·´å¹¾æ¬¡å°±èƒ½æŒ‘æˆ°æ›´é«˜é›£åº¦å›‰ï½`, className: 'feedback-good' };
            } else if (normalizedScore >= 40) {
                return { text: `ğŸ™‚ é‚„å¯ä»¥ï½ä¸‹æ¬¡è©¦è‘—åˆ¥è®“è›‡ã€Œè‡ªç›¸æ®˜æ®ºã€ï¼Ÿ`, className: 'feedback-ok' };
            } else if (normalizedScore >= 10) {
                return { text: `ğŸ˜… è›‡ï¼šã€Œä¸»äººï¼Œæˆ‘é ­å¥½æšˆâ€¦ã€<br>ï¼ˆå»ºè­°å…ˆå¾ç°¡å–®æ¨¡å¼é–‹å§‹ï¼‰`, className: 'feedback-bad' };
            } else {
                return { text: `ğŸ’€ å“‡ï¼é€™å¯èƒ½æ˜¯å²ä¸Šæœ€å¿«ã€Œè‡ªæ®ºå¼è¡æ’ã€â€¦<br>è¦ä¸è¦å…ˆçœ‹çœ‹æ•™å­¸å½±ç‰‡ï¼Ÿ`, className: 'feedback-terrible' };
            }
        }
        
        // æ§åˆ¶
        function handleKey(e) {
            if (!gameRunning) return;
            
            if (e.key === ' ') {
                e.preventDefault();
                togglePause();
                return;
            }
            
            if (gamePaused) return;
            
            switch (e.key) {
                case 'ArrowUp': case 'w': case 'W':
                    if (direction !== 'down') nextDirection = 'up'; break;
                case 'ArrowDown': case 's': case 'S':
                    if (direction !== 'up') nextDirection = 'down'; break;
                case 'ArrowLeft': case 'a': case 'A':
                    if (direction !== 'right') nextDirection = 'left'; break;
                case 'ArrowRight': case 'd': case 'D':
                    if (direction !== 'left') nextDirection = 'right'; break;
            }
        }

        function togglePause() {
            if (!gameRunning) return;
            gamePaused = !gamePaused;
            pauseOverlay.style.display = gamePaused ? 'flex' : 'none';
        }
        
        document.addEventListener('keydown', handleKey);
        restartBtn.addEventListener('click', initGame);
        startBtn.addEventListener('click', initGame);
        difficultySelect.addEventListener('change', () => {
            if (gameRunning) initGame();
        });

        // é»æ“Š canvas ä¹Ÿå¯é–‹å§‹ï¼ˆæ‰‹æ©Ÿå‹å¥½ï¼‰
        canvas.addEventListener('click', () => {
            if (!gameRunning && startScreen.style.display !== 'none') {
                initGame();
            }
        });
    </script>
</body>
</html>